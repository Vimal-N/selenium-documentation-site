[
{
	"uri": "https://selenium.dev/documentation/es/driver_idiosyncrasies/shared_capabilities/",
	"title": "Capacidades compartidas",
	"tags": [],
	"description": "",
	"content": " Estrategia de carga de la página (pageLoadStrategy) Al navegar a una nueva página a través de URL, por defecto Selenium esperará hasta que la página se haya cargado completamente antes de responder. Esto funciona bien para principiantes, pero puede causar largos tiempos de espera en páginas que cargan una gran cantidad de recursos de terceros. El uso de una estrategia no predeterminada puede hacer que la ejecución de la prueba sea más rápida en casos como este, pero también puede introducir inestabilidad donde los elementos en la página cambian de posición a medida que los elementos se cargan y cambian de tamaño.\nLa estrategia de carga de la página consulta el document.readyState como se describe en la tabla a continuación:\n   Estrategia Ready State Notas     normal complete Usado por defecto, espera a que se descarguen todos los recursos   eager interactive El acceso DOM está listo, pero otros recursos como las imágenes aún pueden estar cargando   none Any No bloquea WebDriver en absoluto    "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/captchas/",
	"title": "Captchas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n CAPTCHA, short for Completely Automated Public Turing test to tell Computers and Humans Apart, is explicitly designed to prevent automation, so don’t try! There are two primary strategies to get around CAPTCHA checks:\n Disable CAPTCHAs in your test environment Add a hook to allow tests to bypass the CAPTCHA  "
},
{
	"uri": "https://selenium.dev/documentation/es/front_matter/copyright_and_attributions/",
	"title": "Derechos de autor y atribuciones",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n The Documentation of Selenium Copyright \u0026copy; 2013-2019 , Software Freedom Conservancy.\nEvery effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book. No patent liability is assumed with respect to the use of the information contained herein.\nAttributions Thanks to: Selenium Main Repository .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @shs96c4361 commits \n@barancev2779 commits \n@jimevans2268 commits \n@jleyba1464 commits \n@jarib1298 commits \n@dfabulich1175 commits \n@illicitonion1162 commits \n@AutomatedTester761 commits \n@lukeis599 commits \n@eranmes473 commits \n@mdub326 commits \n@p0deje323 commits \n@titusfortner308 commits \n@andreastt289 commits \n@krosenvold225 commits \n@hugs205 commits \n@davehunt200 commits \n@hbchai191 commits \n@lmtierney179 commits \n@ph7147 commits \n@freynaud138 commits \n@samitbadle137 commits \n@nirvdrum133 commits \n@sevaseva115 commits \n@gigix109 commits \n@juangj108 commits \n@aslakhellesoy94 commits \n@alex-savchuk90 commits \n@andrashatvani66 commits \n@ajayk63 commits \n@asashour48 commits \n@twalpole48 commits \n@mikemelia46 commits \n@jherault44 commits \n@tebeka44 commits \n@santiycr41 commits \n@mach636 commits \n@luke-hill34 commits \n@ddavison31 commits \n@joshbruning30 commits \n@mikebroberts28 commits \n@diemol23 commits \n@valfirst22 commits \n@JohnChen021 commits \n@bret20 commits \n@cgoldberg20 commits \n@by-example19 commits \n@rbri16 commits \n@alb-i98614 commits \n@krmahadevan14 commits \n@bayandin12 commits \n@jayakumarc12 commits \n@carlosgcampos11 commits \n@43081j11 commits \n@detro10 commits \n@josephg10 commits \n@redsquirrel9 commits \n@RustyNail9 commits \n@corevo9 commits \n@InstyleVII8 commits \n@tourdedave8 commits \n@glib-briia7 commits \n@llaskin7 commits \n@DrMarcII7 commits \n@mmerrell7 commits \n@User2534897 commits \n@dratler7 commits \n@dima-groupon6 commits \n@nikolas6 commits \n@Herst5 commits \n@Dude-X5 commits \n@jimvm5 commits \n@JohanLorenzo5 commits \n@oddui5 commits \n@adiohana5 commits \n@Zitrax4 commits \n@dbo4 commits \n@xaircore4 commits \n@sangaline4 commits \n@Ardesco4 commits \n@klepikov4 commits \n@tobli4 commits \n@yizeng4 commits \n@abotalov4 commits \n@dylanlive4 commits \n@JasnoWa4 commits \n@mcharsley4 commits \n@GQAssurance4 commits \n@mojwang4 commits \n@alexhenrie3 commits \n@chrisblock3 commits \n@Marketionist3 commits \n@epall3 commits \n@thorn03 commits \n@johnjbarton3 commits \n@zch3 commits \n@Dominator0083 commits \n@nschonni3 commits \n@olleolleolle3 commits \n@chandrap3 commits \n\nSelenium IDE .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @corevo2445 commits \n@tourdedave610 commits \n@baimao843788 commits \n@Jongkeun51 commits \n@petermouse36 commits \n@LinYunWen36 commits \n@zavelevsky34 commits \n@xdennisx15 commits \n@dvd9006 commits \n@manoj97883 commits \n@shs96c3 commits \n@zewa6663 commits \n@lukeis2 commits \n@Meir0172 commits \n@toshiya2 commits \n@amitzur1 commits \n@aplorenzen1 commits \n@diemol1 commits \n@p26351 commits \n@avoid3d1 commits \n@sotayamashita1 commits \n@samitbadle1 commits \n@swes11171 commits \n@vivrichards6001 commits \n@bolasblack1 commits \n@peter-kehl1 commits \n\nDocker Selenium .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @diemol201 commits \n@ddavison133 commits \n@mtscout653 commits \n@kayabendroth50 commits \n@elgalu24 commits \n@WillAbides8 commits \n@marten-cz5 commits \n@MacCracken5 commits \n@jsa345 commits \n@garagepoort4 commits \n@METAJIJI4 commits \n@manoj97884 commits \n@ZainabSalameh4 commits \n@vasikarla4 commits \n@chenrui3334 commits \n@niQo4 commits \n@testphreak4 commits \n@Remi-p3 commits \n@tnguyen143 commits \n@alexgibson3 commits \n@jeff-jk3 commits \n@pabloFuente3 commits \n@chuckg2 commits \n@davehunt2 commits \n@glib-briia2 commits \n@joaoluizjoaquim2 commits \n@mathieu-pousse2 commits \n@phensley2 commits \n@kaifried2 commits \n@ryneeverett2 commits \n@wheleph2 commits \n@schmunk422 commits \n@a-k-g1 commits \n@alexkogon1 commits \n@deviantintegral1 commits \n@anto-ac1 commits \n@ay0o1 commits \n@gensc0041 commits \n@budtmo1 commits \n@charford1 commits \n@cyrille-leclerc1 commits \n@deiwin1 commits \n@enolan1 commits \n@evertones1 commits \n@hnryjms1 commits \n@doublemarket1 commits \n@hazmeister1 commits \n@McGriddle1 commits \n@jamesottaway1 commits \n@jarspi1 commits \n@BeyondEvil1 commits \n@ja8zyjits1 commits \n@jwhitlock1 commits \n@jonaseicher1 commits \n@CaffeinatedCM1 commits \n@karel19801 commits \n@kmala1 commits \n@lcnja1 commits \n@lmtierney1 commits \n@lukeis1 commits \n@m15o1 commits \n@michallepicki1 commits \n@mikewrighton1 commits \n@meeroslaph1 commits \n@nicolaiparlog1 commits \n@double161 commits \n@reinholdfuereder1 commits \n@remcorakers1 commits \n@rjatkins1 commits \n@scottturley1 commits \n@sethuster1 commits \n@smccarthy1 commits \n@stigkj1 commits \n@tadashi07131 commits \n@gitter-badger1 commits \n@graingert1 commits \n@ThomasMeschke1 commits \n@cvakiitho1 commits \n@torstenwalter1 commits \n@victor-catalyst1 commits \n@vv-p1 commits \n@wesmcouch1 commits \n@reegnz1 commits \n@eitany1 commits \n@miyajan1 commits \n@mgingras1 commits \n@mirkotschaeni1 commits \n@mkrei1 commits \n@neben1 commits \n@oleg-filiutsich1 commits \n@wildloop1 commits \n\nSelenium Website \u0026amp; Docs .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @diemol69 commits \n@alenros28 commits \n@AlexAndradeSan25 commits \n@Harsha50917 commits \n@selenium-ci11 commits \n@liushilive6 commits \n@boris7795 commits \n@jesanmar14 commits \n@hiroksarker3 commits \n@manoj97883 commits \n@cambiph3 commits \n@Bredda2 commits \n@miekof2 commits \n@ilhanoztozlu2 commits \n@imba-tjd2 commits \n@adithyab941 commits \n@barancev1 commits \n@bongosway1 commits \n@f97gujo1 commits \n@misiekofski1 commits \n@TheTestLynx1 commits \n@shs96c1 commits \n@9484624481 commits \n\nPrevious Selenium Website .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @lukeis417 commits \n@shs96c90 commits \n@tourdedave87 commits \n@pgrandje79 commits \n@barancev63 commits \n@lightbody59 commits \n@ajayk40 commits \n@tarun3kumar40 commits \n@ddavison36 commits \n@davehunt26 commits \n@manoj978824 commits \n@peter-kehl22 commits \n@lmtierney21 commits \n@samitbadle21 commits \n@santiycr19 commits \n@illicitonion17 commits \n@pnewhook14 commits \n@AutomatedTester12 commits \n@rasmusbergpalm11 commits \n@juangj11 commits \n@lukeis-sfdc10 commits \n@andreastt7 commits \n@hugs6 commits \n@jarib5 commits \n@jimevans5 commits \n@llaskin5 commits \n@PaulKC5 commits \n@titusfortner5 commits \n@corevo5 commits \n@asashour2 commits \n@oleksandr-lobunets2 commits \n@alex-savchuk2 commits \n@javabrett2 commits \n@darrincherry2 commits \n@eranmes2 commits \n@hazmeister2 commits \n@julianharty2 commits \n@mikemelia2 commits \n@paul-hammant2 commits \n@labkey-tchad2 commits \n@abhijain26182 commits \n@agabrys1 commits \n@azawawi1 commits \n@alb-i9861 commits \n@hollingsworthd1 commits \n@diemol1 commits \n@dylans1 commits \n@EmidioStani1 commits \n@FagnerMartinsBrack1 commits \n@Xaeroxe1 commits \n@JamesZoft1 commits \n@jleyba1 commits \n@JasnoWa1 commits \n@JustAGuyTryingToCodeSomething1 commits \n@kdamball1 commits \n@laurin11 commits \n@klamping1 commits \n@krmahadevan1 commits \n@krosenvold1 commits \n@mmerrell1 commits \n@grawk1 commits \n@mcavigelli1 commits \n@michaelwowro1 commits \n@muralidharand1 commits \n@meeroslaph1 commits \n@NickAb1 commits \n@ohadschn1 commits \n@oifland1 commits \n@rbri1 commits \n@roydekleijn1 commits \n@QuinnWilton1 commits \n@smatei1 commits \n@harrissAvalon1 commits \n@stevedesmond-ca1 commits \n@Vimal-N1 commits \n@yasinguzel1 commits \n@tobecrazy1 commits \n@Zearin1 commits \n@beckendorff1 commits \n@daveOrleans1 commits \n@androiddriver1 commits \n@mauk811 commits \n@pharry221 commits \n@prab21121 commits \n@refactoror1 commits \n@rogerdc1 commits \n@tibord1 commits \n@ygmarchi1 commits \n\nPrevious Documentation Rewrite Project .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @andreastt197 commits \n@selenium-ci105 commits \n@diemol53 commits \n@hazmeister30 commits \n@santiycr27 commits \n@AlexAndradeSan25 commits \n@lukeis21 commits \n@Harsha50917 commits \n@ddavison16 commits \n@davehunt12 commits \n@manoj978812 commits \n@orieken12 commits \n@djangofan12 commits \n@liushilive8 commits \n@User2534897 commits \n@jimholmes6 commits \n@imba-tjd6 commits \n@mmerrell6 commits \n@shs96c6 commits \n@picimako5 commits \n@vijay445 commits \n@xrobotika5 commits \n@cambiph5 commits \n@jesanmar14 commits \n@nvonop4 commits \n@rivlinp4 commits \n@sheg4 commits \n@detro3 commits \n@Ardesco3 commits \n@TheTestLynx3 commits \n@boris7792 commits \n@Bredda2 commits \n@juperala2 commits \n@lmtierney2 commits \n@systemboogie2 commits \n@palotas2 commits \n@miekof2 commits \n@sri852 commits \n@hoanluu2 commits \n@ilhanoztozlu2 commits \n@paul-barton2 commits \n@sourabhkt2 commits \n@adithyab941 commits \n@alenros1 commits \n@p0deje1 commits \n@AJ-721 commits \n@abotalov1 commits \n@bhardin1 commits \n@chamiz1 commits \n@dennybiasiolli1 commits \n@donhuvy1 commits \n@bongosway1 commits \n@nicegraham1 commits \n@f97gujo1 commits \n@JakimLi1 commits \n@austenjt1 commits \n@kmcgon1 commits \n@MartinDelille1 commits \n@michael-coleman1 commits \n@misiekofski1 commits \n@MilanMasek1 commits \n@rakib-amin1 commits \n@NRezek1 commits \n@nikai3d1 commits \n@OndraM1 commits \n@whhone1 commits \n@yarix1 commits \n@ZbigniewZabost1 commits \n@agmen1 commits \n@hking-shutterfly1 commits \n@jimevans1 commits \n@9484624481 commits \n@marilyn1 commits \n@riccione1 commits \n@tungla1 commits \n@zeljkofilipin1 commits \n\nThird-Party software used by Selenium documentation project:    Software Version License     Hugo v0.55.6 Apache 2.0   Hugo Learn Theme v2.3.0 MIT   Code Tabs Style \u0026mdash; MIT    HTML version and source code An HTML version of this documentation is freely available from https://seleniumhq.github.io/docs.\nThe source code for the examples included, and for the book itself is available from the Selenium documentation repository at https://seleniumhq.github.io/docs. See instructions on how to check out the code via git at https://help.github.com/articles/fetching-a-remote/.\nLicense All code and documentation originating from the Selenium project is licensed under the Apache 2.0 license, with the Software Freedom Conservancy as the copyright holder.\nThe license is included here for convenience, but you can also find it on the Apache Foundation\u0026rsquo;s websites:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/the_selenium_project_and_tools/",
	"title": "El proyecto Selenium y herramientas",
	"tags": [],
	"description": "",
	"content": " Selenium controla navegadores web Selenium es muchas cosas, pero en esencia es un conjunto de herramientas para la automatización del navegador web que utiliza las mejores técnicas disponibles para controlar de forma remota las instancias del navegador y emular la interacción de un usuario con el navegador.\nPermite a los testers simular actividades comunes realizadas por los usuarios finales; ingresar texto en los campos, seleccionar valores desplegables y casillas de verificación, y hacer clic en los enlaces de los documentos. También proporciona muchos otros controles, como el movimiento del mouse, la ejecución arbitraria de JavaScript y mucho más.\nAunque se utiliza principalmente para la prueba de front-end de sitios web, Selenium es en esencia una Librería de agente de usuario de navegador. Las interfaces son ubicuas a la aplicación, lo que fomenta la relación con otras librerías para adaptarse a su necesidad.\nUna interfaz para gobernarlos a todos Uno de los principios rectores del proyecto es admitir una interfaz común para los principales navegadores web. Los navegadores web son aplicaciones increíblemente complejas y de alta ingeniería, que realizan sus operaciones de formas completamente diferentes, pero que con frecuencia se ven iguales al hacerlo. Aunque el texto se representa en las mismas fuentes, las imágenes se muestran en el mismo lugar y los enlaces lo llevan al mismo destino. Lo que sucede debajo es tan diferente como la noche y el día. Selenium \u0026ldquo;resume\u0026rdquo; estas diferencias, ocultando sus detalles y complejidades a la persona que escribe el código. Esto le permite escribir varias líneas de código para realizar un flujo de trabajo complicado, pero estas mismas líneas se ejecutarán en Firefox, Internet Explorer, Chrome y todos los demás navegadores compatibles.\nHerramientas y soporte El enfoque de diseño minimalista de Selenium le da versatilidad para ser incluido como componente en aplicaciones más grandes. La infraestructura circundante proporcionada bajo Selenium le brinda las herramientas para armar su propia Grid de navegadores o grid para que las pruebas se puedan ejecutar en diferentes navegadores y múltiples sistemas operativos en una amplia gama de máquinas.\nImagine un banco de computadoras en la sala de servidores o en el centro de datos que activan todos los navegadores al mismo tiempo que hacen clic en los enlaces, formularios y tablas de su sitio, probando su aplicación las 24 horas del día. A través de la interfaz de programación simple provista para los lenguajes más comunes, estas pruebas se ejecutarán incansablemente en paralelo y le informarán cuando ocurran errores.\nEs un objetivo ayudar a que esto sea una realidad para usted, proporcionando a los usuarios herramientas y documentación para controlar no solo los navegadores, sino también para facilitar la ejecución a gran escala y la implementación de dichas Grids.\nQuién usa Selenium Muchas de las compañías más importantes del mundo han adoptado Selenium para sus pruebas basadas en navegadores, a menudo reemplazando los esfuerzos de años que involucran otras herramientas propietarias. A medida que ha crecido en popularidad, también se han multiplicado sus requisitos y desafíos.\nA medida que la web se vuelve más complicada y se agregan nuevas tecnologías a los sitios web, la misión de este proyecto es mantenerse al día con ellos siempre que sea posible. Al ser un proyecto de código abierto, este apoyo se brinda a través de la generosa donación de tiempo de muchos voluntarios, cada uno de los cuales tiene un \u0026ldquo;trabajo diario\u0026rdquo;.\nOtra misión del proyecto es alentar a más voluntarios a participar en este esfuerzo, y construir una comunidad fuerte para que el proyecto pueda seguir el ritmo de las tecnologías emergentes y seguir siendo una plataforma dominante para la automatización de pruebas funcionales.\nHistoria Cuando Selenium 1 se lanzó en 2004, la necesidad era reducir el tiempo dedicado a verificar manualmente el comportamiento consistente en el front-end de una aplicación web. Se hizo uso de las herramientas disponibles en ese momento y se basó en gran medida en la inyección de JavaScript en la página web bajo prueba para emular la interacción de un usuario. Si bien JavaScript es una buena herramienta para permitirle introspectar las propiedades del DOM y hacer ciertas observaciones del lado del cliente que de otro modo no podría hacer, no tiene la capacidad de replicar de forma natural las interacciones de un usuario como el uso del teclado y ratón.\nDesde entonces, Selenium ha crecido y madurado mucho, convirtiéndose en una herramienta ampliamente utilizada por muchas, si no la mayoría, de las organizaciones más grandes del mundo. Selenium ha pasado de ser un kit de herramientas de automatización de pruebas de fabricación casera desarrollado en Thoughtworks para un público especial y un caso de uso específico, a la librería de automatización del navegador de facto en el mundo.\nDel mismo modo que Selenium RC hizo uso de las herramientas del mercado disponibles en ese momento, Selenium WebDriver impulsa esa tradición al llevar la parte de interacción del navegador al territorio del desarrollador del navegador y pedirles que se responsabilicen de las implementaciones de back-end orientadas al navegador. Recientemente, este trabajo se ha convertido en un proceso de estandarización W3C donde el objetivo es convertir el componente WebDriver en Selenium en la libería de control remoto de uso cumún para las simulaciones de agentes de usuario.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/understanding_the_components/",
	"title": "Entendiendo los componentes",
	"tags": [],
	"description": "",
	"content": " Construir una suite de test usando WebDriver requerirá que entiendas y uses de forma efectiva diferentes componentes. Como con todo en el desarrollo de software, la gente usa diferentes términos para la misma idea. A continuación hay un desglose de cómo los términos son usados en esa descripción.\nTerminología  API: Interfaz de Programación de Aplicaciones. Es un conjunto de \u0026ldquo;comandos\u0026rdquo; que se utilizan para manipular el WebDriver. Library: Un módulo de código que contiene las APIs y el código necesario para implementarlos. Las librerías son específicas para cada lenguaje, por ejemplo ficheros .jar en Java, ficheros .dll para .NET, etc. Driver: El responsable de controlar el navegador actual. La mayoría de los drivers son creados por los vendors del navegador. Los Drivers son generalmente módulos ejecutables que corren en el sistema con el propio navegador, no en el sistema ejecutando la suite de test. (Aunque esos pueden ser el mismo sistema.) NOTE: Algunas personas se refieren a los drivers como proxies. Framework: Una librería adicional usada como un soporte para la suites de WebDriver. Estos frameworks pueden ser test frameworks como JUnit o NUnit. También pueden ser frameworks soportando lenguaje natural como Cucumber o Robotium. Los frameworks también pueden ser escritos y usados para cosas como la manipulación o configuración del sistema bajo la prueba, creación de datos, test oracles, etc  Las Partes y las Piezas Como mínimo, el WebDriver habla con un navegador a través del driver. La comunicación es bidireccional: el WebDriver pasa comandos al navegador a través del driver, y recive la información de vuelta por la misma ruta.\nEl driver es específico para el navegador, como es ChromeDriver para Chrome/Chromium de Google, GeckoDriver para Mozilla Firefox, etc. El driver corre en el mismo sistema que el browser. Esto puede, o no puede ser, el mismo sistema donde los tests se están ejecutando.\nEste simple ejemplo anterior es de comunicación directa. La comunicación con el navegador puede ser remota a través de Selenium Server o RemoteWebdriver. Éste último corre en el mismo sistema que el driver y el browser.\nLa comunicación remota puede también hacerse usando Selenium Server o Selenium Grid, ambos a su vez hablan con el driver en el sistema anfitrión.\nDónde encaja el Framework El WebDriver tiene un trabajo y solo un trabajo: comunicarse con el navegador a través de uno de los métodos nombrados. El WebDriver no tiene que saber nada sobre testing: no sabe cómo comparar cosas, asegurar un pass o fail, y ciertamente no sabe nada acerca de reportes o sobre la gramática Given/When/Then.\nAquí es donde varios frameworks entran en juego. Como mínimo neesitarás un framework de test que compare los enlaces de idiomas, por ejempolo NUnit para .NET, JUnit para Java, RSpec para Ruby, etc.\nEl framework de test es responsable de correr y ejecutar tu WebDriver y los pasos de tus tests. Como tal, puedes pensar que se parece a la siguiente imagen.\nLos frameworks o herramientas de lenguage natural como Cucumber pueden existir como parte de la caja de Test Framework de la figura de arriba, o envolver totalmente el Test Framework en su propia implementación.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started/quick/",
	"title": "Guía rápida",
	"tags": [],
	"description": "",
	"content": " Selenium no es solo una herramienta o API, sino que compone muchas herramientas.\nWebDriver WebDriver también se conoce como Selenium 2. Si está comenzando con la automatización de pruebas de sitios web de escritorio, entonces va a utilizar las API de WebDriver. WebDriver utiliza las API de automatización del navegador proporcionadas por los desarrolladores de los navegadores para controlar el navegador y ejecutar pruebas. Esto es como si un usuario real estuviera manipulando el navegador. Dado que el WebDriver no requiere que su API se compile con el código de la aplicación que va a probar, no es de naturaleza intrusiva. Por lo tanto, está probando la misma aplicación que está en vivo.\nControl remoto Remote Control también se conoce como Selenium 1. Selenium RC fue la herramienta de Selenium más destacada antes del advenimiento de Selenium WebDriver. Selenium RC usaba un servidor proxy e inyectaba JavaScript en un navegador para poder controlarlo. Dada la naturaleza intrusiva que Selenium RC tenía en un navegador, nunca podría estar seguro de si lo que estaba probando era lo mismo que la aplicación que quería publicar (desplegar). Las API de Selenium 2 todavía contienen API de Selenium RC, pero Selenium 3 eliminará completamente las API de Selenium RC. Si todavía utiliza Selenium RC, debe migrar a Selenium WebDriver.\nIDE IDE es un complemento de Firefox que se puede utilizar para grabar los pasos de prueba en el propio Firefox. Selenium IDE se puede utilizar para generar código de prueba rápido y sucio (quick and dirty) en una variedad de lenguajes de programación (es decir, C #, Java, Python y Ruby). Dada la mantenibilidad del código generado a través de Selenium IDE, no se recomienda usarlo para nada más que familiarizarse con los localizadores (locators) de elementos o generar código descartable (throw away code). Estamos seguros de que una vez que se acostumbre a la API WebDriver, nunca usará Selenium IDE.\nGrid Poco después del desarrollo de las pruebas de WebDriver, es posible que deba ejecutar sus pruebas en múltiples combinaciones de navegador y sistema operativo. Aquí es donde Grid viene al rescate.\nHTML Runner Esta herramienta le permite ejecutar Test Suites desde la línea de comandos. Las suites de prueba son exportaciones HTML desde Selenium IDE o herramientas compatibles. HTML Runner\n"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/installing_selenium_libraries/",
	"title": "Instalación de las librerías Selenium",
	"tags": [],
	"description": "",
	"content": " Primero debe instalar las librerías de Selenium para su proyecto de automatización. El proceso de instalación de las librerías depende del lenguaje que elija usar.\nJava La instalación de las bibliotecas Selenium para Java se puede hacer usando Maven. Agregue la dependencia selenium-java en el archivo pom.xml de su proyecto:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; La dependencia de selenium-java admite la ejecución de su proyecto de automatización con todos los navegadores compatibles con Selenium. Si desea ejecutar pruebas solo en un navegador específico, puede agregar la dependencia para ese navegador en su archivo pom.xml. Por ejemplo, debe agregar la siguiente dependencia en su archivo pom.xml para ejecutar sus pruebas solo en Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De manera similar, si desea ejecutar pruebas solo en Chrome, debe agregar la siguiente dependencia:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python La instalación de las librerías de Selenium en Python se puede hacer usando pip:\npip install selenium Alternativamente, puede descargar el archivo fuente PyPI (selenium-x.x.x.tar.gz) e instalarlo usando setup.py:\npython setup.py install C# La instalación de las librerías de Selenium para C# se puede hacer usando NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby La instalación de las librerías de Selenium para Ruby se puede hacer usando gem:\ngem install selenium-webdriver JavaScript La instalación de las librerías de Selenium para JavaScript se puede hacer usando npm:\nnpm install selenium-webdriver"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/page_object_models/",
	"title": "Modelos de objetos de página",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Page Object is a Design Pattern which has become popular in test automation for enhancing test maintenance and reducing code duplication. A page object is an object-oriented class that serves as an interface to a page of your AUT*. The tests then use the methods of this page object class whenever they need to interact with that page of the UI. The benefit is that if the UI changes for the page, the tests themselves do not need to change; only the code within the page object needs to change. Subsequently, all changes to support that new UI are located in one place.\nThe Page Object Design Pattern provides the following advantage: there is clean separation between test code and page specific code such as locators (or their use if you are using a UI map) and layout.\nPage object methods should return a value  If you submit a page and are redirected, it should return the new page object. If you click submit on login and you want to check to see if a user is logged in, it should return True or False in a method.   *AUT: Application under test\n"
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/browser_navigation/",
	"title": "Navegación",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n There are commands for various webpage loading actions:\nJava Python C# Ruby JavaScript Kotlin // Navigate to a URL (both of the statements below are // functionally equivalent). driver.get(\u0026#34;https://www.google.com\u0026#34;); driver.navigate().to(\u0026#34;https://www.google.com\u0026#34;); // Go forward one page in the browser (if you\u0026#39;re not on the // last page that was viewed). driver.navigate().forward(); // Go back one page in the browser (if you\u0026#39;re not on the // first page that was viewed). driver.navigate().back(); // Refresh the current page. driver.navigate().refresh();   # Navigate to a URL. driver.get(\u0026#39;https://www.google.com\u0026#39;) # Go forward one page in the browser (if you\u0026#39;re not on the # last page that was viewed). driver.forward() # Go back one page in the browser (if you\u0026#39;re not on the # first page that was viewed). driver.back() # Refresh the current page. driver.refresh()   // Navigate to a URL driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); // Go forward one page in the browser (if you\u0026#39;re not on the // last page that was viewed). driver.Navigate().Forward(); // Go back one page in the browser (if you\u0026#39;re not on the // first page that was viewed). driver.Navigate().Back(); // Refresh the current page. driver.Navigate().Refresh();   # Navigate to a URL (both of the statements below are # functionally equivalent). driver.get(\u0026#39;https://www.google.com\u0026#39;) driver.navigate.to(\u0026#39;https://www.google.com\u0026#39;) # Go forward one page in the browser (if you\u0026#39;re not on the # last page that was viewed). driver.navigate.forward # Go back one page in the browser (if you\u0026#39;re not on the # first page that was viewed). driver.navigate.back # Refresh the current page. driver.navigate.refresh   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Navigate to a URL (both of the statements below are // functionally equivalent). driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.navigate().to(\u0026#34;https://www.google.com\u0026#34;) // Go forward one page in the browser (if you\u0026#39;re not on the // last page that was viewed). driver.navigate().forward() // Go back one page in the browser (if you\u0026#39;re not on the // first page that was viewed). driver.navigate().back() // Refresh the current page. driver.navigate().refresh()     "
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/browsers/",
	"title": "Navegadores",
	"tags": [],
	"description": "",
	"content": " Navegadores (Browsers) de consumidores El marco Selenium admite oficialmente los siguientes navegadores:\n   Navegador Desarrollador Versiones soportadas     Chromium Chromium Todas las versiones   Firefox Mozilla 54 y recientes   Internet Explorer Selenium 6 y recientes   Opera Opera Chromium / Presto 10.5 y recientes   Safari Apple 10 y recientes    Navegadores especializados También hay un conjunto de navegadores especializados que generalmente se usan en entornos de desarrollo. También podemos utilizar algunos de estos navegadores para fines de automatización, y Selenium se vincula con el soporte para los siguientes controladores especializados:\n   Nombre del controlador Propósito Desarrollador     HtmlUnitDriver Emulador de navegador sin cabeza (headless) por Rhino Selenium project    "
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started/",
	"title": "Primeros pasos",
	"tags": [],
	"description": "",
	"content": " Primeros pasos Si es nuevo en Selenium, tenemos algunos recursos que pueden ayudarlo a ponerse al día de inmediato.\n Guía rápida  WebDriver Control Remoto IDE Grid HTML Runner   "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/purposes_and_main_functionalities/",
	"title": "Propósitos y funcionalidades principales",
	"tags": [],
	"description": "",
	"content": " Punto de entrada central para todas las pruebas Gestión y control de los nodos / entorno donde se ejecutan los navegadores Ejecución de pruebas a gran escala Ejecución de pruebas en paralelo Pruebas de diferentes plataformas (Cross-platform and cross-browser) Balanceo de carga  "
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Introduction Selenium RC was the main Selenium project for a long time, before the WebDriver/Selenium merge brought up Selenium 2, a more powerful tool. It is worth to highlight that Selenium 1 is not supported anymore.\nHow Selenium RC Works First, we will describe how the components of Selenium RC operate and the role each plays in running your test scripts.\nRC Components Selenium RC components are:\n The Selenium Server which launches and kills browsers, interprets and runs the Selenese commands passed from the test program, and acts as an HTTP proxy, intercepting and verifying HTTP messages passed between the browser and the AUT. Client libraries which provide the interface between each programming language and the Selenium RC Server.  Here is a simplified architecture diagram:\nThe diagram shows the client libraries communicate with the Server passing each Selenium command for execution. Then the server passes the Selenium command to the browser using Selenium-Core JavaScript commands. The browser, using its JavaScript interpreter, executes the Selenium command. This runs the Selenese action or verification you specified in your test script.\nSelenium Server Selenium Server receives Selenium commands from your test program, interprets them, and reports back to your program the results of running those tests.\nThe RC server bundles Selenium Core and automatically injects it into the browser. This occurs when your test program opens the browser (using a client library API function). Selenium-Core is a JavaScript program, actually a set of JavaScript functions which interprets and executes Selenese commands using the browser\u0026rsquo;s built-in JavaScript interpreter.\nThe Server receives the Selenese commands from your test program using simple HTTP GET/POST requests. This means you can use any programming language that can send HTTP requests to automate Selenium tests on the browser.\nClient Libraries The client libraries provide the programming support that allows you to run Selenium commands from a program of your own design. There is a different client library for each supported language. A Selenium client library provides a programming interface (API), i.e., a set of functions, which run Selenium commands from your own program. Within each interface, there is a programming function that supports each Selenese command.\nThe client library takes a Selenese command and passes it to the Selenium Server for processing a specific action or test against the application under test (AUT). The client library also receives the result of that command and passes it back to your program. Your program can receive the result and store it into a program variable and report it as a success or failure, or possibly take corrective action if it was an unexpected error.\nSo to create a test program, you simply write a program that runs a set of Selenium commands using a client library API. And, optionally, if you already have a Selenese test script created in the Selenium-IDE, you can generate the Selenium RC code. The Selenium-IDE can translate (using its Export menu item) its Selenium commands into a client-driver\u0026rsquo;s API function calls. See the Selenium-IDE chapter for specifics on exporting RC code from Selenium-IDE.\nInstallation Installation is rather a misnomer for Selenium. Selenium has a set of libraries available in the programming language of your choice. You could download them from the downloads page.\nOnce you\u0026rsquo;ve chosen a language to work with, you simply need to:\n Install the Selenium RC Server. Set up a programming project using a language specific client driver.  Installing Selenium Server The Selenium RC server is simply a Java jar file (selenium-server-standalone-.jar), which doesn\u0026rsquo;t require any special installation. Just downloading the zip file and extracting the server in the desired directory is sufficient.\nRunning Selenium Server Before starting any tests you must start the server. Go to the directory where Selenium RC\u0026rsquo;s server is located and run the following from a command-line console.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar This can be simplified by creating a batch or shell executable file (.bat on Windows and .sh on Linux) containing the command above. Then make a shortcut to that executable on your desktop and simply double-click the icon to start the server.\nFor the server to run you\u0026rsquo;ll need Java installed and the PATH environment variable correctly configured to run it from the console. You can check that you have Java correctly installed by running the following on a console.\njava -version If you get a version number (which needs to be 1.5 or later), you\u0026rsquo;re ready to start using Selenium RC.\nUsing the Java Client Driver  Download Selenium java client driver zip from the SeleniumHQ downloads page. Extract selenium-java-.jar file Open your desired Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Create a java project. Add the selenium-java-.jar files to your project as references. Add to your project classpath the file selenium-java-.jar. From Selenium-IDE, export a script to a Java file and include it in your Java project, or write your Selenium test in Java using the selenium-java-client API. The API is presented later in this chapter. You can either use JUnit, or TestNg to run your test, or you can write your own simple main() program. These concepts are explained later in this section. Run Selenium server from the console. Execute your test from the Java IDE or from the command-line.  For details on Java test project configuration, see the Appendix sections Configuring Selenium RC With Eclipse and Configuring Selenium RC With Intellij.\nUsing the Python Client Driver  Install Selenium via PIP, instructions linked at SeleniumHQ downloads page Either write your Selenium test in Python or export a script from Selenium-IDE to a python file. Run Selenium server from the console Execute your test from a console or your Python IDE  For details on Python client driver configuration, see the appendix Python Client Driver Configuration.\nUsing the .NET Client Driver  Download Selenium RC from the SeleniumHQ downloads page Extract the folder Download and install NUnit ( Note: You can use NUnit as your test engine. If you\u0026rsquo;re not familiar yet with NUnit, you can also write a simple main() function to run your tests; however NUnit is very useful as a test engine.) Open your desired .Net IDE (Visual Studio, SharpDevelop, MonoDevelop) Create a class library (.dll) Add references to the following DLLs: nmock.dll, nunit.core.dll, nunit. framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll and ThoughtWorks.Selenium.UnitTests.dll Write your Selenium test in a .Net language (C#, VB.Net), or export a script from Selenium-IDE to a C# file and copy this code into the class file you just created. Write your own simple main() program or you can include NUnit in your project for running your test. These concepts are explained later in this chapter. Run Selenium server from console Run your test either from the IDE, from the NUnit GUI or from the command line  For specific details on .NET client driver configuration with Visual Studio, see the appendix .NET client driver configuration.\nUsing the Ruby Client Driver  If you do not already have RubyGems, install it from RubyForge. Run gem install selenium-client At the top of your test script, add require \u0026quot;selenium/client\u0026quot; Write your test script using any Ruby test harness (eg Test::Unit, Mini::Test or RSpec). Run Selenium RC server from the console. Execute your test in the same way you would run any other Ruby script.  For details on Ruby client driver configuration, see the Selenium-Client documentation_\nFrom Selenese to a Program The primary task for using Selenium RC is to convert your Selenese into a programming language. In this section, we provide several different language-specific examples.\nSample Test Script Let\u0026rsquo;s start with an example Selenese test script. Imagine recording the following test with Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Note: This example would work with the Google search page http://www.google.com\nSelenese as Programming Code Here is the test script exported (via Selenium-IDE) to each of the supported programming languages. If you have at least basic knowledge of an object- oriented programming language, you will understand how Selenium runs Selenese commands by reading one of these examples. To see an example in a specific language, select one of these buttons.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } }  Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt;  Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end In the next section we\u0026rsquo;ll explain how to build a test program using the generated code.\nProgramming Your Test Now we\u0026rsquo;ll illustrate how to program your own tests using examples in each of the supported programming languages. There are essentially two tasks:\n Generate your script into a programming language from Selenium-IDE, optionally modifying the result.\n Write a very simple main program that executes the generated code.\n  Optionally, you can adopt a test engine platform like JUnit or TestNG for Java, or NUnit for .NET if you are using one of those languages.\nHere, we show language-specific examples. The language-specific APIs tend to differ from one to another, so you\u0026rsquo;ll find a separate explanation for each.\n Java C# Python Ruby Perl, PHP  Java For Java, people use either JUnit or TestNG as the test engine.\nSome development environments like Eclipse have direct support for these via plug-ins. This makes it even easier. Teaching JUnit or TestNG is beyond the scope of this document however materials may be found online and there are publications available. If you are already a \u0026ldquo;java-shop\u0026rdquo; chances are your developers will already have some experience with one of these test frameworks.\nYou will probably want to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The Selenium-IDE generated code will look like this. This example has comments added manually for additional clarity.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# The .NET Client Driver works with Microsoft.NET. It can be used with any .NET testing framework like NUnit or the Visual Studio 2005 Team System.\nSelenium-IDE assumes you will use NUnit as your testing framework. You can see this in the generated code below. It includes the using statement for NUnit along with corresponding NUnit attributes identifying the role for each member function of the test class.\nYou will probably have to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;);  The generated code will look similar to this.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } }  You can allow NUnit to manage the execution of your tests. Or alternatively, you can write a simple main() program that instantiates the test object and runs each of the three methods, SetupTest(), TheNewTest(), and TeardownTest() in turn.\nPython Pyunit is the test framework to use for Python.\nThe basic test structure is:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Old (pre 2.0) versions of Selenium-IDE generate Ruby code that requires the old Selenium gem. Therefore, it is advisable to update any Ruby scripts generated by the IDE as follows:\n On line 1, change require \u0026quot;selenium\u0026quot; to require \u0026quot;selenium/client\u0026quot;\n On line 11, change Selenium::SeleniumDriver.new to Selenium::Client::Driver.new\n  You probably also want to change the class name to something more informative than \u0026ldquo;Untitled,\u0026rdquo; and change the test method\u0026rsquo;s name to something other than \u0026ldquo;test_untitled.\u0026rdquo;\nHere is a simple example created by modifying the Ruby code generated by Selenium IDE, as described above.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP The members of the documentation team have not used Selenium RC with Perl or PHP. If you are using Selenium RC with either of these two languages please contact the Documentation Team (see the chapter on contributing). We would love to include some examples from you and your experiences, to support Perl and PHP users.\nLearning the API The Selenium RC API uses naming conventions that, assuming you understand Selenese, much of the interface\nwill be self-explanatory. Here, however, we explain the most critical and possibly less obvious aspects.\nStarting the Browser CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start();  Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Each of these examples opens the browser and represents that browser by assigning a \u0026ldquo;browser instance\u0026rdquo; to a program variable. This program variable is then used to call methods from the browser. These methods execute the Selenium commands, i.e. like open or type or the verify commands.\nThe parameters required when creating the browser instance are:\n host Specifies the IP address of the computer where the server is located. Usually, this is the same machine as where the client is running, so in this case localhost is passed. In some clients this is an optional parameter.\n port Specifies the TCP/IP socket where the server is listening waiting for the client to establish a connection. This also is optional in some client drivers.\n browser The browser in which you want to run the tests. This is a required parameter.\n url The base url of the application under test. This is required by all the client libs and is integral information for starting up the browser-proxy-AUT communication.\n  Note that some of the client libraries require the browser to be started explicitly by calling its start() method.\nRunning Commands Once you have the browser initialized and assigned to a variable (generally named \u0026ldquo;selenium\u0026rdquo;) you can make it run Selenese commands by calling the respective methods from the browser variable. For example, to call the type method of the selenium object:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) In the background the browser will actually perform a type operation, essentially identical to a user typing input into the browser, by\nusing the locator and the string you specified during the method call.\nReporting Results Selenium RC does not have its own mechanism for reporting results. Rather, it allows you to build your reporting customized to your needs using features of your chosen programming language. That\u0026rsquo;s great, but what if you simply want something quick that\u0026rsquo;s already done for you? Often an existing library or test framework can meet your needs faster than developing your own test reporting code.\nTest Framework Reporting Tools Test frameworks are available for many programming languages. These, along with their primary function of providing a flexible test engine for executing your tests, include library code for reporting results. For example, Java has two commonly used test frameworks, JUnit and TestNG. .NET also has its own, NUnit.\nWe won\u0026rsquo;t teach the frameworks themselves here; that\u0026rsquo;s beyond the scope of this user guide. We will simply introduce the framework features that relate to Selenium along with some techniques you can apply. There are good books available on these test frameworks however along with information on the internet.\nTest Report Libraries Also available are third-party libraries specifically created for reporting test results in your chosen programming language. These often support a variety of formats such as HTML or PDF.\nWhat\u0026rsquo;s The Best Approach? Most people new to the testing frameworks will begin with the framework\u0026rsquo;s built-in reporting features. From there most will examine any available libraries as that\u0026rsquo;s less time consuming than developing your own. As you begin to use Selenium no doubt you will start putting in your own \u0026ldquo;print statements\u0026rdquo; for reporting progress. That may gradually lead to you developing your own reporting, possibly in parallel to using a library or test framework. Regardless, after the initial, but short, learning curve you will naturally develop what works best for your own situation.\nTest Reporting Examples To illustrate, we\u0026rsquo;ll direct you to some specific tools in some of the other languages supported by Selenium. The ones listed here are commonly used and have been used extensively (and therefore recommended) by the authors of this guide.\nTest Reports in Java  If Selenium Test cases are developed using JUnit then JUnit Report can be used to generate test reports.\n If Selenium Test cases are developed using TestNG then no external task is required to generate test reports. The TestNG framework generates an HTML report which list details of tests.\n ReportNG is a HTML reporting plug-in for the TestNG framework. It is intended as a replacement for the default TestNG HTML report. ReportNG provides a simple, colour-coded view of the test results.\n  Logging the Selenese Commands  Logging Selenium can be used to generate a report of all the Selenese commands in your test along with the success or failure of each. Logging Selenium extends the Java client driver to add this Selenese logging ability.  Test Reports for Python  When using Python Client Driver then HTMLTestRunner can be used to generate a Test Report.  Test Reports for Ruby  If RSpec framework is used for writing Selenium Test Cases in Ruby then its HTML report can be used to generate a test report.  Adding Some Spice to Your Tests Now we\u0026rsquo;ll get to the whole reason for using Selenium RC, adding programming logic to your tests. It\u0026rsquo;s the same as for any program. Program flow is controlled using condition statements and iteration. In addition you can report progress information using I/O. In this section we\u0026rsquo;ll show some examples of how programming language constructs can be combined with Selenium to solve common testing problems.\nYou will find as you transition from the simple tests of the existence of page elements to tests of dynamic functionality involving multiple web-pages and varying data that you will require programming logic for verifying expected results. Basically, the Selenium-IDE does not support iteration and standard condition statements. You can do some conditions by embedding javascript in Selenese parameters, however iteration is impossible, and most conditions will be much easier in a\nprogramming language. In addition, you may need exception handling for error recovery. For these reasons and others, we have written this section to illustrate the use of common programming techniques to give you greater \u0026lsquo;verification power\u0026rsquo; in your automated testing.\nThe examples in this section are written in C# and Java, although the code is simple and can be easily adapted to the other supported languages. If you have some basic knowledge of an object-oriented programming language you shouldn\u0026rsquo;t have difficulty understanding this section.\nIteration Iteration is one of the most common things people need to do in their tests. For example, you may want to to execute a search multiple times. Or, perhaps for verifying your test results you need to process a \u0026ldquo;result set\u0026rdquo; returned from a database.\nUsing the same Google search example we used earlier, let\u0026rsquo;s check the Selenium search results. This test could use the Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     The code has been repeated to run the same steps 3 times. But multiple copies of the same code is not good program practice because it\u0026rsquo;s more work to maintain. By using a programming language, we can iterate over the search results for a more flexible and maintainable solution.\nIn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); }  Condition Statements To illustrate using conditions in tests we\u0026rsquo;ll start with an example. A common problem encountered while running Selenium tests occurs when an expected element is not available on page. For example, when running the following line:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); If element \u0026lsquo;q\u0026rsquo; is not on the page then an exception is thrown:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found This can cause your test to abort. For some tests that\u0026rsquo;s what you want. But often that is not desirable as your test script has many other subsequent tests to perform.\nA better approach is to first validate whether the element is really present and then take alternatives when it it is not. Let\u0026rsquo;s look at this using Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } The advantage of this approach is to continue with test execution even if some UI elements are not available on page.\nExecuting JavaScript from Your Test JavaScript comes very handy in exercising an application which is not directly supported by selenium. The getEval method of selenium API can be used to execute JavaScript from selenium RC.\nConsider an application having check boxes with no static identifiers. In this case one could evaluate JavaScript from selenium RC to get ids of all check boxes and then exercise them.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } To count number of images on a page:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Remember to use window object in case of DOM expressions as by default selenium window is referred to, not the test window.\nServer Options When the server is launched, command line options can be used to change the default server behaviour.\nRecall, the server is started by running the following.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar To see the list of options, run the server with the -h option.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h You\u0026rsquo;ll see a list of all the options you can use with the server and a brief description of each. The provided descriptions will not always be enough, so we\u0026rsquo;ve provided explanations for some of the more important options.\nProxy Configuration If your AUT is behind an HTTP proxy which requires authentication then you should configure http.proxyHost, http.proxyPort, http.proxyUser and http.proxyPassword using the following command.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Multi-Window Mode If you are using Selenium 1.0 you can probably skip this section, since multiwindow mode is the default behavior. However, prior to version 1.0, Selenium by default ran the application under test in a sub frame as shown here.\nSome applications didn\u0026rsquo;t run correctly in a sub frame, and needed to be loaded into the top frame of the window. The multi-window mode option allowed the AUT to run in a separate window rather than in the default frame where it could then have the top frame it required.\nFor older versions of Selenium you must specify multiwindow mode explicitly with the following option:\n-multiwindow  As of Selenium RC 1.0, if you want to run your test within a single frame (i.e. using the standard for earlier Selenium versions) you can state this to the Selenium Server using the option\n-singlewindow  Specifying the Firefox Profile Firefox will not run two instances simultaneously unless you specify a separate profile for each instance. Selenium RC 1.0 and later runs in a separate profile automatically, so if you are using Selenium 1.0, you can probably skip this section. However, if you\u0026rsquo;re using an older version of Selenium or if you need to use a specific profile for your tests (such as adding an https certificate or having some addons installed), you will need to explicitly specify the profile.\nFirst, to create a separate Firefox profile, follow this procedure. Open the Windows Start menu, select \u0026ldquo;Run\u0026rdquo;, then type and enter one of the following:\nfirefox.exe -profilemanager firefox.exe -P  Create the new profile using the dialog. Then when you run Selenium Server, tell it to use this new Firefox profile with the server command-line option -firefoxProfileTemplate and specify the path to the profile using its filename and directory path.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34;  Warning: Be sure to put your profile in a new folder separate from the default!!! The Firefox profile manager tool will delete all files in a folder if you delete a profile, regardless of whether they are profile files or not.\nMore information about Firefox profiles can be found in Mozilla\u0026rsquo;s Knowledge Base\nRun Selenese Directly Within the Server Using -htmlSuite You can run Selenese html files directly within the Selenium Server by passing the html file to the server\u0026rsquo;s command line. For instance:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; This will automatically launch your HTML suite, run all the tests and save a nice HTML report with the results.\nNote: When using this option, the server will start the tests and wait for a specified number of seconds for the test to complete; if the test doesn\u0026rsquo;t complete within that amount of time, the command will exit with a non-zero exit code and no results file will be generated.\nThis command line is very long so be careful when you type it. Note this requires you to pass in an HTML Selenese suite, not a single test. Also be aware the -htmlSuite option is incompatible with -interactive You cannot run both at the same time.\nSelenium Server Logging Server-Side Logs When launching selenium server the -log option can be used to record valuable debugging information reported by the Selenium Server to a text file.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log This log file is more verbose than the standard console logs (it includes DEBUG level logging messages). The log file also includes the logger name, and the ID number of the thread that logged the message. For example:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW The message format is\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE This message may be multiline.\nBrowser-Side Logs JavaScript on the browser side (Selenium Core) also logs important messages; in many cases, these can be more useful to the end-user than the regular Selenium Server logs. To access browser-side logs, pass the -browserSideLog argument to the Selenium Server.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog must be combined with the -log argument, to log browserSideLogs (as well as all other DEBUG level logging messages) to a file.\nSpecifying the Path to a Specific Browser You can specify to Selenium RC a path to a specific browser. This is useful if you have different versions of the same browser and you wish to use a specific one. Also, this is used to allow your tests to run against a browser not directly supported by Selenium RC. When specifying the run mode, use the *custom specifier followed by the full path to the browser\u0026rsquo;s executable:\n*custom \u0026lt;path to browser\u0026gt;  Selenium RC Architecture Note: This topic tries to explain the technical implementation behind Selenium RC. It\u0026rsquo;s not fundamental for a Selenium user to know this, but could be useful for understanding some of the problems you might find in the future.\nTo understand in detail how Selenium RC Server works and why it uses proxy injection and heightened privilege modes you must first understand the same origin policy_.\nThe Same Origin Policy The main restriction that Selenium faces is the Same Origin Policy. This security restriction is applied by every browser in the market and its objective is to ensure that a site\u0026rsquo;s content will never be accessible by a script from another site. The Same Origin Policy dictates that any code loaded within the browser can only operate within that website\u0026rsquo;s domain. It cannot perform functions on another website. So for example, if the browser loads JavaScript code when it loads www.mysite.com, it cannot run that loaded code against www.mysite2.com\u0026ndash;even if that\u0026rsquo;s another of your sites. If this were possible, a script placed on any website you open would be able to read information on your bank account if you had the account page opened on other tab. This is called XSS (Cross-site Scripting).\nTo work within this policy, Selenium-Core (and its JavaScript commands that make all the magic happen) must be placed in the same origin as the Application Under Test (same URL).\nHistorically, Selenium-Core was limited by this problem since it was implemented in JavaScript. Selenium RC is not, however, restricted by the Same Origin Policy. Its use of the Selenium Server as a proxy avoids this problem. It, essentially, tells the browser that the browser is working on a single \u0026ldquo;spoofed\u0026rdquo; website that the Server provides.\nNote: You can find additional information about this topic on Wikipedia pages about Same Origin Policy and XSS.\nProxy Injection The first method Selenium used to avoid the The Same Origin Policy was Proxy Injection. In Proxy Injection Mode, the Selenium Server acts as a client-configured HTTP proxy1, that sits between the browser and the Application Under Test2. It then masks the AUT under a fictional URL (embedding Selenium-Core and the set of tests and delivering them as if they were coming from the same origin).\nHere is an architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that injects Selenium-Core\u0026rsquo;s JavaScript into the browser-loaded web page. The client-driver passes a Selenese command to the server. The Server interprets the command and then triggers the corresponding JavaScript execution to execute that command within the browser. Selenium-Core instructs the browser to act on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks for the website\u0026rsquo;s content from the Selenium RC server (set as the HTTP proxy for the browser to use). Selenium RC server communicates with the Web server asking for the page and once it receives it, it sends the page to the browser masking the origin to look like the page comes from the same server as Selenium-Core (this allows Selenium-Core to comply with the Same Origin Policy). The browser receives the web page and renders it in the frame/window reserved for it.   Heightened Privileges Browsers This workflow in this method is very similar to Proxy Injection but the main difference is that the browsers are launched in a special mode called Heightened Privileges, which allows websites to do things that are not commonly permitted (as doing XSS_, or filling file upload inputs and pretty useful stuff for Selenium). By using these browser modes, Selenium Core is able to directly open the AUT and read/interact with its content without having to pass the whole AUT through the Selenium RC server.\nHere is the architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that will load Selenium-Core in the web page. Selenium-Core gets the first instruction from the client/driver (via another HTTP request made to the Selenium RC Server). Selenium-Core acts on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks the Web Server for the page. Once the browser receives the web page, renders it in the frame/window reserved for it.  Handling HTTPS and Security Popups Many applications switch from using HTTP to HTTPS when they need to send encrypted information such as passwords or credit card information. This is common with many of today\u0026rsquo;s web applications. Selenium RC supports this.\nTo ensure the HTTPS site is genuine, the browser will need a security certificate. Otherwise, when the browser accesses the AUT using HTTPS, it will assume that application is not \u0026lsquo;trusted\u0026rsquo;. When this occurs the browser displays security popups, and these popups cannot be closed using Selenium RC.\nWhen dealing with HTTPS in a Selenium RC test, you must use a run mode that supports this and handles the security certificate for you. You specify the run mode when your test program initializes Selenium.\nIn Selenium RC 1.0 beta 2 and later use *firefox or *iexplore for the run mode. In earlier versions, including Selenium RC 1.0 beta 1, use *chrome or *iehta, for the run mode. Using these run modes, you will not need to install any special security certificates; Selenium RC will handle it for you.\nIn version 1.0 the run modes *firefox or *iexplore are recommended. However, there are additional run modes of *iexploreproxy and *firefoxproxy. These are provided for backwards compatibility only, and should not be used unless required by legacy test programs. Their use will present limitations with security certificate handling and with the running of multiple windows if your application opens additional browser windows.\nIn earlier versions of Selenium RC, *chrome or *iehta were the run modes that supported HTTPS and the handling of security popups. These were considered ‘experimental modes although they became quite stable and many people used them. If you are using Selenium 1.0 you do not need, and should not use, these older run modes.\nSecurity Certificates Explained Normally, your browser will trust the application you are testing by installing a security certificate which you already own. You can check this in your browser\u0026rsquo;s options or Internet properties (if you don\u0026rsquo;t know your AUT\u0026rsquo;s security certificate ask your system administrator). When Selenium loads your browser it injects code to intercept messages between the browser and the server. The browser now thinks untrusted software is trying to look like your application. It responds by alerting you with popup messages.\nTo get around this, Selenium RC, (again when using a run mode that support this) will install its own security certificate, temporarily, to your client machine in a place where the browser can access it. This tricks the browser into thinking it\u0026rsquo;s accessing a site different from your AUT and effectively suppresses the popups.\nAnother method used with earlier versions of Selenium was to install the Cybervillians security certificate provided with your Selenium installation. Most users should no longer need to do this however; if you are running Selenium RC in proxy injection mode, you may need to explicitly install this security certificate.\nSupporting Additional Browsers and Browser Configurations The Selenium API supports running against multiple browsers in addition to Internet Explorer and Mozilla Firefox. See the https://selenium.dev website for supported browsers. In addition, when a browser is not directly supported, you may still run your Selenium tests against a browser of your choosing by using the \u0026ldquo;*custom\u0026rdquo; run-mode (i.e. in place of *firefox or *iexplore) when your test application starts the browser. With this, you pass in the path to the browsers executable within the API call. This can also be done from the Server in interactive mode.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Running Tests with Different Browser Configurations Normally Selenium RC automatically configures the browser, but if you launch the browser using the \u0026ldquo;*custom\u0026rdquo; run mode, you can force Selenium RC to launch the browser as-is, without using an automatic configuration.\nFor example, you can launch Firefox with a custom configuration like this:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Note that when launching the browser this way, you must manually configure the browser to use the Selenium Server as a proxy. Normally this just means opening your browser preferences and specifying \u0026ldquo;localhost:4444\u0026rdquo; as an HTTP proxy, but instructions for this can differ radically from browser to browser. Consult your browser\u0026rsquo;s documentation for details.\nBe aware that Mozilla browsers can vary in how they start and stop. One may need to set the MOZ_NO_REMOTE environment variable to make Mozilla browsers behave a little more predictably. Unix users should avoid launching the browser using a shell script; it\u0026rsquo;s generally better to use the binary executable (e.g. firefox-bin) directly.\nTroubleshooting Common Problems When getting started with Selenium RC there\u0026rsquo;s a few potential problems that are commonly encountered. We present them along with their solutions here.\nUnable to Connect to Server When your test program cannot connect to the Selenium Server, Selenium throws an exception in your test program. It should display this message or a similar one:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2)  If you see a message like this, be sure you started the Selenium Server. If so, then there is a problem with the connectivity between the Selenium Client Library and the Selenium Server.\nWhen starting with Selenium RC, most people begin by running their test program (with a Selenium Client Library) and the Selenium Server on the same machine. To do this use \u0026ldquo;localhost\u0026rdquo; as your connection parameter. We recommend beginning this way since it reduces the influence of potential networking problems which you\u0026rsquo;re getting started. Assuming your operating system has typical networking and TCP/IP settings you should have little difficulty. In truth, many people choose to run the tests this way.\nIf, however, you do want to run Selenium Server on a remote machine, the connectivity should be fine assuming you have valid TCP/IP connectivity between the two machines.\nIf you have difficulty connecting, you can use common networking tools like ping, telnet, ifconfig(Unix)/ipconfig (Windows), etc to ensure you have a valid network connection. If unfamilar with these, your system administrator can assist you.\nUnable to Load the Browser Ok, not a friendly error message, sorry, but if the Selenium Server cannot load the browser you will likely see this error.\n(500) Internal Server Error This could be caused by\n Firefox (prior to Selenium 1.0) cannot start because the browser is already open and you did not specify a separate profile. See the section on Firefox profiles under Server Options. The run mode you\u0026rsquo;re using doesn\u0026rsquo;t match any browser on your machine. Check the parameters you passed to Selenium when you program opens the browser. You specified the path to the browser explicitly (using \u0026ldquo;*custom\u0026rdquo;\u0026ndash;see above) but the path is incorrect. Check to be sure the path is correct. Also check the user group to be sure there are no known issues with your browser and the \u0026ldquo;*custom\u0026rdquo; parameters.  Selenium Cannot Find the AUT If your test program starts the browser successfully, but the browser doesn\u0026rsquo;t display the website you\u0026rsquo;re testing, the most likely cause is your test program is not using the correct URL.\nThis can easily happen. When you use Selenium-IDE to export your script, it inserts a dummy URL. You must manually change the URL to the correct one for your application to be tested.\nFirefox Refused Shutdown While Preparing a Profile This most often occurs when you run your Selenium RC test program against Firefox, but you already have a Firefox browser session running and, you didn\u0026rsquo;t specify a separate profile when you started the Selenium Server. The error from the test program looks like this:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile  Here\u0026rsquo;s the complete error message from the server:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock  To resolve this, see the section on Specifying a Separate Firefox Profile\nVersioning Problems Make sure your version of Selenium supports the version of your browser. For example, Selenium RC 0.92 does not support Firefox 3. At times you may be lucky (I was). But don\u0026rsquo;t forget to check which browser versions are supported by the version of Selenium you are using. When in doubt, use the latest release version of Selenium with the most widely used version of your browser.\nError message: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; while starting server This error says you\u0026rsquo;re not using a correct version of Java. The Selenium Server requires Java 1.5 or higher.\nTo check double-check your java version, run this from the command line.\njava -version You should see a message showing the Java version.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) If you see a lower version number, you may need to update the JRE, or you may simply need to add it to your PATH environment variable.\n404 error when running the getNewBrowserSession command If you\u0026rsquo;re getting a 404 error while attempting to open a page on \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, then it must be because the Selenium Server was not correctly configured as a proxy. The \u0026ldquo;selenium-server\u0026rdquo; directory doesn\u0026rsquo;t exist on google.com; it only appears to exist when the proxy is properly configured. Proxy Configuration highly depends on how the browser is launched with firefox, iexplore, opera, or custom.\n iexplore: If the browser is launched using *iexplore, you could be having a problem with Internet Explorer\u0026rsquo;s proxy settings. Selenium Server attempts To configure the global proxy settings in the Internet Options Control Panel. You must make sure that those are correctly configured when Selenium Server launches the browser. Try looking at your Internet Options control panel. Click on the \u0026ldquo;Connections\u0026rdquo; tab and click on \u0026ldquo;LAN Settings\u0026rdquo;.\n If you need to use a proxy to access the application you want to test, you\u0026rsquo;ll need to start Selenium Server with \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; see the Proxy Configuration_ for more details. You may also try configuring your proxy manually and then launching the browser with *custom, or with *iehta browser launcher.   custom: When using *custom you must configure the proxy correctly(manually), otherwise you\u0026rsquo;ll get a 404 error. Double-check that you\u0026rsquo;ve configured your proxy settings correctly. To check whether you\u0026rsquo;ve configured the proxy correctly is to attempt to intentionally configure the browser incorrectly. Try configuring the browser to use the wrong proxy server hostname, or the wrong port. If you had successfully configured the browser\u0026rsquo;s proxy settings incorrectly, then the browser will be unable to connect to the Internet, which is one way to make sure that one is adjusting the relevant settings.\n For other browsers (*firefox, *opera) we automatically hard-code the proxy for you, and so there are no known issues with this functionality. If you\u0026rsquo;re encountering 404 errors and have followed this user guide carefully post your results to user group for some help from the user community.\n  Permission Denied Error The most common reason for this error is that your session is attempting to violate the same-origin policy by crossing domain boundaries (e.g., accesses a page from http://domain1 and then accesses a page from http://domain2) or switching protocols (moving from http://domainX to https://domainX).\nThis error can also occur when JavaScript attempts to find UI objects which are not yet available (before the page has completely loaded), or are no longer available (after the page has started to be unloaded). This is most typically encountered with AJAX pages which are working with sections of a page or subframes that load and/or reload independently of the larger page.\nThis error can be intermittent. Often it is impossible to reproduce the problem with a debugger because the trouble stems from race conditions which are not reproducible when the debugger\u0026rsquo;s overhead is added to the system. Permission issues are covered in some detail in the tutorial. Read the section about the The Same Origin Policy, Proxy Injection carefully.\nHandling Browser Popup Windows There are several kinds of \u0026ldquo;Popups\u0026rdquo; that you can get during a Selenium test. You may not be able to close these popups by running selenium commands if they are initiated by the browser and not your AUT. You may need to know how to manage these. Each type of popup needs to be addressed differently.\n HTTP basic authentication dialogs: These dialogs prompt for a username/password to login to the site. To login to a site that requires HTTP basic authentication, use a username and password in the URL, as described in RFC 1738_, like this: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n SSL certificate warnings: Selenium RC automatically attempts to spoof SSL certificates when it is enabled as a proxy; see more on this in the section on HTTPS. If your browser is configured correctly, you should never see SSL certificate warnings, but you may need to configure your browser to trust our dangerous \u0026ldquo;CyberVillains\u0026rdquo; SSL certificate authority. Again, refer to the HTTPS section for how to do this.\n modal JavaScript alert/confirmation/prompt dialogs: Selenium tries to conceal those dialogs from you (by replacing window.alert, window.confirm and window.prompt) so they won\u0026rsquo;t stop the execution of your page. If you\u0026rsquo;re seeing an alert pop-up, it\u0026rsquo;s probably because it fired during the page load process, which is usually too early for us to protect the page. Selenese contains commands for asserting or verifying alert and confirmation popups. See the sections on these topics in Chapter 4.\n  On Linux, why isn\u0026rsquo;t my Firefox browser session closing? On Unix/Linux you must invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so make sure that executable is on the path. If executing Firefox through a shell script, when it comes time to kill the browser Selenium RC will kill the shell script, leaving the browser running. You can specify the path to firefox-bin directly, like this.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome doesn\u0026rsquo;t work with custom profile Check Firefox profile folder -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comment this line like this: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; and try again.\nIs it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page\u0026rsquo;s javascript window.onload() function runs)? No. Selenium relies on interceptors to determine window names as they are being loaded. These interceptors work best in catching new windows if the windows are loaded AFTER the onload() function. Selenium may not recognize windows loaded before the onload function.\nFirefox on Linux On Unix/Linux, versions of Selenium before 1.0 needed to invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so if you are using a previous version, make sure that the real executable is on the path.\nOn most Linux distributions, the real firefox-bin is located on:\n/usr/lib/firefox-x.x.x/  Where the x.x.x is the version number you currently have. So, to add that path to the user\u0026rsquo;s path. you will have to add the following to your .bashrc file:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; If necessary, you can specify the path to firefox-bin directly in your test, like this:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE and Style Attributes If you are running your tests on Internet Explorer and you cannot locate elements using their style attribute. For example:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] This would work perfectly in Firefox, Opera or Safari but not with IE. IE interprets the keys in @style as uppercase. So, even if the source code is in lowercase, you should use:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] This is a problem if your test is intended to work on multiple browsers, but you can easily code your test to detect the situation and try the alternative locator that only works in IE.\nError encountered - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; with shut down of *googlechrome browser To avoid this error you have to start browser with an option that disables same origin policy checks:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Error encountered in IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; To avoid this error you have to configure the browser: disable the popup blocker AND uncheck \u0026lsquo;Enable Protected Mode\u0026rsquo; option in Tools \u0026gt;\u0026gt; Options \u0026gt;\u0026gt; Security.\n The proxy is a third person in the middle that passes the ball between the two parts. It acts as a \u0026ldquo;web server\u0026rdquo; that delivers the AUT to the browser. Being a proxy gives Selenium Server the capability of \u0026ldquo;lying\u0026rdquo; about the AUT\u0026rsquo;s real URL.\n[return] The browser is launched with a configuration profile that has set localhost:4444 as the HTTP proxy, this is why any HTTP request that the browser does will pass through Selenium server and the response will pass through it and not from the real server. [return]   "
},
{
	"uri": "https://selenium.dev/documentation/es/remote_webdriver/remote_webdriver_server/",
	"title": "WebDriver remoto - servidor",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n The server will always run on the machine with the browser you want to test. The server can be used either from the command line or through code configuration.\nStarting the server from the command line Once you have downloaded selenium-server-standalone-{VERSION}.jar, place it on the computer with the browser you want to test. Then, from the directory with the jar, run the following:\njava -jar selenium-server-standalone-{VERSION}.jar Considerations for running the server The caller is expected to terminate each session properly, calling either Selenium#stop() or WebDriver#quit.\nThe selenium-server keeps in-memory logs for each ongoing session, which are cleared when Selenium#stop() or WebDriver#quit is called. If you forget to terminate these sessions, your server may leak memory. If you keep extremely long-running sessions, you will probably need to stop/quit every now and then (or increase memory with -Xmx jvm option).\nTimeouts (from version 2.21) The server has two different timeouts, which can be set as follows:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controls how long the browser is allowed to hang (value in seconds).  timeout  Controls how long the client is allowed to be gone before the session is reclaimed (value in seconds).   The system property selenium.server.session.timeout is no longer supported as of 2.21.\nPlease note that the browserTimeout is intended as a backup timeout mechanism when the ordinary timeout mechanism fails, which should be used mostly in grid/server environments to ensure that crashed/lost processes do not stay around for too long, polluting the runtime environment.\nConfiguring the server programmatically In theory, the process is as simple as mapping the DriverServlet to a URL, but it\u0026rsquo;s also possible to host the page in a lightweight container, such as Jetty configured entirely in code. Steps to do this follow.\nDownload the selenium-server.zip and unpack. Put the JARs on the CLASSPATH. Create a new class called AppServer. Here, I\u0026rsquo;m using Jetty, so you\u0026rsquo;ll need to download that as well:\nimport org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } }"
},
{
	"uri": "https://selenium.dev/documentation/es/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "Capacidades especificas de los controladores",
	"tags": [],
	"description": "",
	"content": " Firefox Definir Capacidades (Capabilities) usando FirefoxOptions FirefoxOptions es la nueva forma de definir capacidades para el navegador Firefox y, por lo general, debe usarse con preferencia a las capacidades deseadas.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   # Todavía no tenemos una muestra de código Ruby: ayúdenos y genere un PR (_pull request_)   // Todavía no tenemos una muestra de código JavaScript: ayúdenos y genere un PR (_pull request_)    val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Configuración de un perfil personalizado Es posible crear un perfil personalizado para Firefox como se muestra a continuación.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   # Todavía no tenemos una muestra de código Ruby: ayúdenos y genere un PR (_pull request_)   // Todavía no tenemos una muestra de código JavaScript: ayúdenos y genere un PR (_pull request_)    val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout En algunos entornos, Internet Explorer puede agotar el tiempo de espera al abrir el cuadro de diálogo Cargar archivo. IEDriver tiene un tiempo de espera predeterminado de 1000 ms, pero puede aumentar el tiempo de espera usando la capability fileUploadDialogTimeout.\nJava Python C# Ruby JavaScript Kotlin // We don\u0026#39;t have a Java code sample yet - Help us out and raise a PR    # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR      "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/components_of_a_grid/",
	"title": "Componentes de un Grid",
	"tags": [],
	"description": "",
	"content": " Concentrador o Hub  Intermediario y administrador Acepta solicitudes para ejecutar pruebas Toma instrucciones del cliente y las ejecuta de forma remota en los nodos Administra hilos  Un hub es un punto central al que se envían todas sus pruebas. Cada Selenium Grid consta de un centro exactamente. El concentrador debe ser accesible desde los respectivos clientes (es decir, servidor CI (Continuos Integration), máquina del desarrollador, etc.) El concentrador conectará uno o más nodos a los que se delegarán las pruebas.\nNodos  Aquí es donde viven los navegadores Se registra en el centro y comunica sus capacidades Recibe solicitudes del hub y las ejecuta  Los \u0026ldquo;nodos\u0026rdquo; son instancias diferentes de Selenium que ejecutarán pruebas en sistemas informáticos individuales. Puede haber muchos nodos en una grid. Las máquinas que son nodos no necesitan ser de la misma plataforma o tener la misma selección de navegador que la del concentrador u otros nodos. Un nodo en Windows podría tener la capacidad de ofrecer Internet Explorer como una opción de navegador, mientras que esto no sería posible en Linux o Mac.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Controladores de otros fabricantes y plugins",
	"tags": [],
	"description": "",
	"content": "El Selenium se puede ampliar o extender mediante el uso de complementos (plugins). Aquí hay una serie de complementos creados y mantenidos por terceros. Para obtener más información sobre cómo crear su propio complemento o tenerlo en la lista, consulte los documentos.\nTenga en cuenta que estos complementos no son compatibles, mantenidos, alojados o respaldados por el proyecto Selenium. Además, tenga en cuenta que los complementos que se enumeran a continuación no están necesariamente autorizados bajo la licencia Apache v.2.0. Algunos de los complementos están disponibles bajo otra licencia de software libre y de código abierto; otros solo están disponibles bajo una licencia patentada. Cualquier pregunta sobre los complementos y su licencia de distribución debe plantearse con sus respectivos desarrolladores.\n   Navegador Versión reciente Control de cambios Hallazgos Documentación     Google ChromeDriver 2.29 changelog issues wiki    "
},
{
	"uri": "https://selenium.dev/documentation/es/front_matter/typographical_conventions/",
	"title": "Convenciones tipográficas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Capitalisation of titles One should avoid title capitalisation, such as A Very Fine Heading, and instead go for A very fine heading. Gratutious capitalisation, or title case, often show a misunderstanding of – or a disregard for – orthographic conventions. We prefer what is known as sentence case, with a single initial capital to start headers.\nLine length When editing the documentation’s source, which is written in plain HTML, limit your line lengths to around 72 characters.\nSome of us take this one step further and use what is called semantic linefeeds, which is a technique whereby the HTML source lines, which are not read by the public, are split at ‘natural breaks’ in the prose. In other words, sentences are split at natural breaks between clauses. Instead of fussing with the lines of each paragraph so that they all end near the right margin, linefeeds can be added anywhere that there is a break between ideas.\nThis can make diffs very easy to read when collaborating through git, but it is not something we enforce contributors to use.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/file_downloads/",
	"title": "Descarga de archivos",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Whilst it is possible to start a download by clicking a link with a browser under Selenium\u0026rsquo;s control, the API does not expose download progress, making it less than ideal for testing downloaded files. This is because downloading files is not considered an important aspect of emulating user interaction with the web platform. Instead, find the link using Selenium (and any required cookies) and pass it to a HTTP request library like libcurl.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started/html-runner/",
	"title": "HTML runner",
	"tags": [],
	"description": "",
	"content": " Selenium HTML-runner le permite ejecutar Test Suites desde una línea de comandos. Las suites de prueba son exportaciones HTML desde Selenium IDE o herramientas compatibles.\nInformación común  La combinación de lanzamientos de geckodriver / firefox / selenium-html runner es importante. Puede haber una matriz de compatibilidad de software en alguna parte. selenium-html-runner solo ejecuta Test Suite (no Test Case, lo que es, por ejemplo, una exportación de Monitis Transaction Monitor). Asegúrese de cumplir con esto. Para usuarios de Linux sin PANTALLA: debe iniciar html-runner con pantalla virtual (busque xvfb).  Ejemplo de un entorno Linux Descargue e instale los siguientes paquetes de software:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Ejemplo de la Test Suite:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;es\u0026#34; lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;SU-ESCENARIO-DE-PRUEBAS\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Cómo ejecutar el elenium-html-runner sin cabeza (headless) Ahora, la parte más importante, ¡un ejemplo de cómo ejecutar selenium-html-runner! Su experiencia puede variar según las combinaciones de software: versiones geckodriver / Firefox / html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html[user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt;"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/installing_webdriver_binaries/",
	"title": "Instalación de las librerías WebDriver",
	"tags": [],
	"description": "",
	"content": "Para ejecutar su proyecto y controlar el navegador, debe tener instalados los binarios de WebDriver específicos del navegador.\nDescargue el binario del WebDriver compatible con su navegador y colóquelo en el RUTA o PATH del sistema.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/",
	"title": "Introducción",
	"tags": [],
	"description": "",
	"content": " Introducción Selenium es un proyecto que cobija una gama de herramientas y bibliotecas que permiten y soportan la automatización de los navegadores web.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/domain_specific_language/",
	"title": "Lenguage de dominio específico",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n A domain specific language (DSL) is a system which provides the user with an expressive means of solving a problem. It allows a user to interact with the system on their terms – not just programmer-speak.\nYour users, in general, do not care how your site looks. They do not care about the decoration, animations, or graphics. They want to use your system to push their new employees through the process with minimal difficulty; they want to book travel to Alaska; they want to configure and buy unicorns at a discount. Your job as tester is to come as close as you can to “capturing” this mind-set. With that in mind, we set about “modeling” the application you are working on, such that the test scripts (the user\u0026rsquo;s only pre-release proxy) “speak” for, and represent the user.\nWith Selenium, DSL is usually represented by methods, written to make the API simple and readable – they enable a report between the developers and the stakeholders (users, product owners, business intelligence specialists, etc.).\nBenefits  Readable: Business stakeholders can understand it. Writable: Easy to write, avoids unnecessary duplication. Extensible: Functionality can (reasonably) be added without breaking contracts and existing functionality. Maintainable: By leaving the implementation details out of test cases, you are well-insulated against changes to the AUT*.  Java Here is an example of a reasonable DSL method in Java. For brevity\u0026rsquo;s sake, it assumes the driver object is pre-defined and available to the method.\n/** * Takes a username and password, fills out the fields, and clicks \u0026#34;login\u0026#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we\u0026#39;re using is \u0026#34;By.id\u0026#34;, and we should  // have it defined elsewhere in the class.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Click the login button, which happens to have the id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Create and return a new instance of the AccountPage (via the built-in Selenium  // PageFactory).  return PageFactory.newInstance(AccountPage.class); } This method completely abstracts the concepts of input fields, buttons, clicking, and even pages from your test code. Using this approach, all a tester has to do is call this method. This gives you a maintenance advantage: if the login fields ever changed, you would only ever have to change this method - not your tests.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Now that we\u0026#39;re logged in, do some other stuff--since we used a DSL to support  // our testers, it\u0026#39;s as easy as choosing from available methods.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Note that we still haven\u0026#39;t referred to a button or web control anywhere in this  // script... } It bears repeating: one of your primary goals should be writing an API that allows your tests to address the problem at hand, and NOT the problem of the UI. The UI is a secondary concern for your users – they do not care about the UI, they just want to get their job done. Your test scripts should read like a laundry list of things the user wants to DO, and the things they want to KNOW. The tests should not concern themselves with HOW the UI requires you to go about it.\n*AUT: Application under test\n"
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "Migrating from RC to WebDriver",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n How to Migrate to Selenium WebDriver A common question when adopting Selenium 2 is what\u0026rsquo;s the correct thing to do when adding new tests to an existing set of tests? Users who are new to the framework can begin by using the new WebDriver APIs for writing their tests. But what of users who already have suites of existing tests? This guide is designed to demonstrate how to migrate your existing tests to the new APIs, allowing all new tests to be written using the new features offered by WebDriver.\nThe method presented here describes a piecemeal migration to the WebDriver APIs without needing to rework everything in one massive push. This means that you can allow more time for migrating your existing tests, which may make it easier for you to decide where to spend your effort.\nThis guide is written using Java, because this has the best support for making the migration. As we provide better tools for other languages, this guide shall be expanded to include those languages.\nWhy Migrate to WebDriver Moving a suite of tests from one API to another API requires an enormous amount of effort. Why would you and your team consider making this move? Here are some reasons why you should consider migrating your Selenium Tests to use WebDriver.\n Smaller, compact API. WebDriver\u0026rsquo;s API is more Object Oriented than the original Selenium RC API. This can make it easier to work with. Better emulation of user interactions. Where possible, WebDriver makes use of native events in order to interact with a web page. This more closely mimics the way that your users work with your site and apps. In addition, WebDriver offers the advanced user interactions APIs which allow you to model complex interactions with your site. Support by browser vendors. Opera, Mozilla and Google are all active participants in WebDriver\u0026rsquo;s development, and each have engineers working to improve the framework. Often, this means that support for WebDriver is baked into the browser itself: your tests run as fast and as stably as possible.  Before Starting In order to make the process of migrating as painless as possible, make sure that all your tests run properly with the latest Selenium release. This may sound obvious, but it\u0026rsquo;s best to have it said!\nGetting Started The first step when starting the migration is to change how you obtain your instance of Selenium. When using Selenium RC, this is done like so:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); This should be replaced like so:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Next Steps Once your tests execute without errors, the next stage is to migrate the actual test code to use the WebDriver APIs. Depending on how well abstracted your code is, this might be a short process or a long one. In either case, the approach is the same and can be summed up simply: modify code to use the new API when you come to edit it.\nIf you need to extract the underlying WebDriver implementation from the Selenium instance, you can simply cast it to WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); This allows you to continue passing the Selenium instance around as normal, but to unwrap the WebDriver instance as required.\nAt some point, you\u0026rsquo;re codebase will mostly be using the newer APIs. At this point, you can flip the relationship, using WebDriver throughout and instantiating a Selenium instance on demand:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Common Problems Fortunately, you\u0026rsquo;re not the first person to go through this migration, so here are some common problems that others have seen, and how to solve them.\nClicking and Typing is More Complete A common pattern in a Selenium RC test is to see something like:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); This relies on the fact that \u0026ldquo;type\u0026rdquo; simply replaces the content of the identified element without also firing all the events that would normally be fired if a user interacts with the page. The final direct invocations of \u0026ldquo;key*\u0026rdquo; cause the JS handlers to fire as expected.\nWhen using the WebDriverBackedSelenium, the result of filling in the form field would be \u0026ldquo;exciting texttt\u0026rdquo;: not what you\u0026rsquo;d expect! The reason for this is that WebDriver more accurately emulates user behavior, and so will have been firing events all along.\nThis same fact may sometimes cause a page load to fire earlier than it would do in a Selenium 1 test. You can tell that this has happened if a \u0026ldquo;StaleElementException\u0026rdquo; is thrown by WebDriver.\nWaitForPageToLoad Returns Too Soon Discovering when a page load is complete is a tricky business. Do we mean \u0026ldquo;when the load event fires\u0026rdquo;, \u0026ldquo;when all AJAX requests are complete\u0026rdquo;, \u0026ldquo;when there\u0026rsquo;s no network traffic\u0026rdquo;, \u0026ldquo;when document.readyState has changed\u0026rdquo; or something else entirely?\nWebDriver attempts to simulate the original Selenium behavior, but this doesn\u0026rsquo;t always work perfectly for various reasons. The most common reason is that it\u0026rsquo;s hard to tell the difference between a page load not having started yet, and a page load having completed between method calls. This sometimes means that control is returned to your test before the page has finished (or even started!) loading.\nThe solution to this is to wait on something specific. Commonly, this might be for the element you want to interact with next, or for some Javascript variable to be set to a specific value. An example would be:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, 30); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Where \u0026ldquo;visibilityOfElementLocated\u0026rdquo; is implemented as:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } This may look complex, but it\u0026rsquo;s almost all boiler-plate code. The only interesting bit is that the \u0026ldquo;ExpectedCondition\u0026rdquo; will be evaluated repeatedly until the \u0026ldquo;apply\u0026rdquo; method returns something that is neither \u0026ldquo;null\u0026rdquo; nor Boolean.FALSE.\nOf course, adding all these \u0026ldquo;wait\u0026rdquo; calls may clutter up your code. If that\u0026rsquo;s the case, and your needs are simple, consider using the implicit waits:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); By doing this, every time an element is located, if the element is not present, the location is retried until either it is present, or until 30 seconds have passed.\nFinding By XPath or CSS Selectors Doesn\u0026rsquo;t Always Work, But It Does In Selenium 1 In Selenium 1, it was common for xpath to use a bundled library rather than the capabilities of the browser itself. WebDriver will always use the native browser methods unless there\u0026rsquo;s no alternative. That means that complex xpath expressions may break on some browsers.\nCSS Selectors in Selenium 1 were implemented using the Sizzle library. This implements a superset of the CSS Selector spec, and it\u0026rsquo;s not always clear where you\u0026rsquo;ve crossed the line. If you\u0026rsquo;re using the WebDriverBackedSelenium and use a Sizzle locator instead of a CSS Selector for finding elements, a warning will be logged to the console. It\u0026rsquo;s worth taking the time to look for these, particularly if tests are failing because of not being able to find elements.\nThere is No Browserbot Selenium RC was based on Selenium Core, and therefore when you executed Javascript, you could access bits of Selenium Core to make things easier. As WebDriver is not based on Selenium Core, this is no longer possible. How can you tell if you\u0026rsquo;re using Selenium Core? Simple! Just look to see if your \u0026ldquo;getEval\u0026rdquo; or similar calls are using \u0026ldquo;selenium\u0026rdquo; or \u0026ldquo;browserbot\u0026rdquo; in the evaluated Javascript.\nYou might be using the browserbot to obtain a handle to the current window or document of the test. Fortunately, WebDriver always evaluates JS in the context of the current window, so you can use \u0026ldquo;window\u0026rdquo; or \u0026ldquo;document\u0026rdquo; directly.\nAlternatively, you might be using the browserbot to locate elements. In WebDriver, the idiom for doing this is to first locate the element, and then pass that as an argument to the Javascript. Thus:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); becomes:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Notice how the passed in \u0026ldquo;element\u0026rdquo; variable appears as the first item in the JS standard \u0026ldquo;arguments\u0026rdquo; array.\nExecuting Javascript Doesn\u0026rsquo;t Return Anything WebDriver\u0026rsquo;s JavascriptExecutor will wrap all JS and evaluate it as an anonymous expression. This means that you need to use the \u0026ldquo;return\u0026rdquo; keyword:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); becomes:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;);"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/driver_requirements/",
	"title": "Requerimientos de los controladores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Through WebDriver, Selenium supports all major browsers on the market such as Chrom(ium), Firefox, Internet Explorer, Opera, and Safari. Where possible, WebDriver drives the browser using the browser\u0026rsquo;s built-in support for automation, although not all browsers have official support for remote control.\nWebDriver\u0026rsquo;s aim is to emulate a real user\u0026rsquo;s interaction with the browser as closely as possible. This is possible at varying levels in different browsers. For more details on the different driver idiosyncracies, please see Driver Idiosyncracies.\nEven though all the drivers share a single user-facing interface for controlling the browser, they have slightly different ways of setting up browser sessions. Since many of the driver implementations are provided by third parties, they are not included in the standard Selenium distribution.\nDriver instantiation, profile management, and various browser specific settings are examples of parameters that have different requirements depending on the browser. This section explains the basic requirements for getting you started with the different browsers.\nAdding Executables to your PATH Most drivers require an extra executable for Selenium to communicate with the browser. You can manually specify where the executable lives before starting WebDriver, but this can make your tests less portable, as the executables will need to be in the same place on every machine, or included within your test code repository.\nBy adding a folder containing WebDriver\u0026rsquo;s binaries to your system\u0026rsquo;s path, Selenium will be able to locate the additional binaries without requiring your test code to locate the exact location of the driver.\n Create a directory to place the executables in, like C:\\WebDriver\\bin or /opt/WebDriver/bin Add the directory to your PATH:\n On Windows - Open a command prompt as administrator and the run the following command to permanently add the directory to your path for all users on your machine:\nsetx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34; Bash users on macOS and Linux - In a terminal:\nexport PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile  You are now ready to test your changes. Close all open command prompts and open a new one. Type out the name of one of the binaries in the folder you created in the previous step, e.g:\nchromedriver If your PATH is configured correctly, you will see some some output relating to the startup of the driver:\nStarting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed.  You can regain control of your command prompt by pressing Ctrl + C\nQuick reference    Browser Supported OS Maintained by Download Issue Tracker     Chromium/Chrome Windows/macOS/Linux Google Downloads Issues   Firefox Windows/macOS/Linux Mozilla Downloads Issues   Edge Windows 10 Microsoft Downloads Issues   Internet Explorer Windows Selenium Project Downloads Issues   Safari macOS El Capitan and newer Apple Built in Issues   Opera Windows/macOS/Linux Opera Downloads Issues    Chromium/Chrome To drive Chrome or Chromium, you have to download chromedriver and put it in a folder that is on your system\u0026rsquo;s path.\nOn Linux or macOS, this means modifying the PATH environmental variable. You can see what directories, separated by a colon, make up your system\u0026rsquo;s path by executing the following command:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin To include chromedriver on the path if it isn\u0026rsquo;t already, make sure you include the chromedriver binary\u0026rsquo;s parent directory. The following line will set the PATH environmental variable its current content, plus an additional path added after the colon:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; When chromedriver is available on your path, you should be able to execute the chromedriver executable from any directory.\nTo instantiate a Chrome/Chromium session, you can do the following:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     Remember that you have to set the path to the chromedriver executable. This is possible using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     The chromedriver is implemented as a WebDriver remote server that by exposing Chrome\u0026rsquo;s internal automation proxy interface instructs the browser what to do.\nFirefox Starting with Selenium 3, Mozilla has taken over implementation of Firefox Driver, with geckodriver. The new driver for Firefox is called geckodriver and works with Firefox 48 and newer. Since the Firefox WebDriver is under development, the newer the Firefox version the better the support.\nAs geckodriver is the new default way of launching Firefox, you can instantiate Firefox in the same way as Selenium 2:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     If you prefer not to set geckodriver\u0026rsquo;s location using PATH, set the geckodriver binary location programmatically:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     It is also possible to set the property at run time:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver It is currently possible to revert to the older, more feature complete Firefox driver, by installing Firefox 47.0.1 or 45 ESR and specifying a desired capability of marionette as false. Later releases of Firefox are no longer compatible.\nEdge Edge is Microsoft\u0026rsquo;s newest browser, included with Windows 10 and Server 2016. Updates to Edge are bundled with major Windows updates, so you\u0026rsquo;ll need to download a binary which matches the build number of your currently installed build of Windows. The Edge Developer site contains links to all the available binaries. Bugs against the EdgeDriver implementation can be raised with Microsoft. If you\u0026rsquo;d like to run tests against Edge, but aren\u0026rsquo;t running Windows 10, Microsoft offer free VMs for testers on the Edge Developer site.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     If Edge driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorer was Microsoft\u0026rsquo;s default browser until Windows 10, although it is still included in Windows 10. Internet Explorer Driver is the only driver The Selenium project aims to support the same releases Microsoft considers current. Older releases may work, but will be unsupported.\nWhile the Selenium project provides binaries for both the 32-bit and 64-bit versions of Internet Explorer, there are some limitations with Internet Explorer 10 \u0026amp; 11 with the 64-bit driver, but using the 32-bit driver continues to work well. It should be noted that as Internet Explorer preferences are saved against the logged in user\u0026rsquo;s account, some additional setup is required.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     If Internet Explorer driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     Microsoft also offer a WebDriver binary for Internet Explorer 11 on Windows 7 \u0026amp; 8.1. It has not been updated since 2014 and is based of a draft version of the W3 specification. Jim Evans has an excellent writeup on Microsoft\u0026rsquo;s implementation.\nOpera Current releases of Opera are built on top of the Chromium engine, and WebDriver is now supported via the closed-source Opera Chromium Driver, which can be added to your PATH or as a system property.\nInstantiating a driver session is similar to Firefox and Chromium:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari Starting with Safari 10 on macOS El Capitan and Sierra, WebDriver support is included with each release of the browser. To enable support:\n Enable the Developer menu from Safari preferences Check the Allow Remote Automation option from with the Develop menu Run the following command from the terminal for the first time and type your password at the prompt to authorise WebDriver\n/usr/bin/safaridriver -p 1337\u0026lt;/  You can then start a driver session using:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     Those looking to automate Safari on iOS should look to the Appium project. Whilst Safari was previously available for Windows, Apple has long since dropped support, making it a poor choice of test platform.\nMock browsers HtmlUnit HtmlUnit is a \u0026ldquo;GUI-Less browser for Java programs\u0026rdquo;. It models HTML documents and provides an API that allows you to invoke pages, fill out forms, click links, etc. It has JavaScript support and is able to work with AJAX libraries, simulating Chrome, Firefox or Internet Explorer depending on the configuration used. It has been moved to a new location. The source is maintained on svn.\nPhantomJS PhantomJS is a headless browser based on Webkit, albeit a version much older than that used by Google Chrome or Safari. Whilst historically a popular choice, it would now be wise to avoid PhantomJS. The project has been unmaintained since the 5th of August, so whilst the web will continue to change, PhantomJS will not be updated. This was after Google announced the ability to run Chrome headlessly, something also now offered by Mozilla\u0026rsquo;s Firefox.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/on_test_automation/",
	"title": "Sobre automatización de pruebas",
	"tags": [],
	"description": "",
	"content": " Antes que nada, pregúntese si realmente necesita o no usar un navegador. Las probabilidades son buenas de que, en algún momento, si está trabajando en una aplicación web compleja, necesitará abrir un navegador y probarla.\nSin embargo, las pruebas funcionales de usuario final, como las pruebas de Selenium, son caras de ejecutar. Además, por lo general requieren una infraestructura sustancial para poder funcionar de manera efectiva. Es una buena regla preguntarse siempre si lo que desea probar se puede hacer utilizando enfoques de prueba más livianos, como pruebas unitarias o con un enfoque de nivel inferior.\nUna vez que haya tomado la determinación de que está en el negocio de las pruebas con un navegador web, y tenga su entorno Selenium listo para comenzar a escribir las pruebas, generalmente realizará una combinación de tres pasos:\n Configurar los datos Realizar un conjunto discreto de acciones Evaluar los resultados  Deberá mantener estos pasos lo más cortos posible; una o dos operaciones deberían ser suficientes la mayor parte del tiempo. La automatización del navegador tiene la reputación de ser \u0026ldquo;inestable\u0026rdquo;, pero en realidad eso se debe a que los usuarios suelen exigir demasiado. En capítulos posteriores, volveremos a las técnicas que puede usar para mitigar aparentes problemas intermitentes en las pruebas, en particular sobre cómo superar las condiciones de carrera entre el navegador y WebDriver.\nAl mantener sus pruebas cortas y usar el navegador web solo cuando no tiene absolutamente ninguna alternativa, puede realizar muchas pruebas con un minimo desgaste.\nUna ventaja distintiva de las pruebas de Selenium es su capacidad inherente para probar todos los componentes de la aplicación, desde el backend hasta el frontend, desde la perspectiva del usuario. En otras palabras, si bien las pruebas funcionales pueden ser costosas de ejecutar, también abarcan grandes porciones críticas para el negocio al mismo tiempo.\nRequisitos de prueba Como se mencionó anteriormente, las pruebas de Selenium pueden ser costosas de ejecutar. Incluso depende del navegador con el que esté ejecutando las pruebas, pero históricamente el comportamiento de los navegadores ha variado tanto que a menudo ha sido un objetivo declarado realizar pruebas con múltiples navegadores (cross browser).\nSelenium le permite ejecutar las mismas instrucciones en múltiples navegadores y en múltiples sistemas operativos, pero la enumeración de todos los navegadores posibles, sus diferentes versiones y los muchos sistemas operativos en los que se ejecutan se le convertirá rápidamente en una tarea compleja.\nComencemos con un ejemplo Larry ha escrito un sitio web que permite a los usuarios ordenar sus propios unicornios personalizados.\nEl flujo de trabajo general (lo que llamaremos el \u0026ldquo;camino feliz\u0026rdquo;) es algo como esto:\n Crea una cuenta Configurar tu unicornio Agrégalo al carrito de compras Echa un vistazo y paga Dar comentarios sobre tu unicornio  Sería tentador escribir un gran script Selenium para realizar todas estas operaciones, muchos lo intentarán. ¡Resista la tentación! Hacerlo dará como resultado una prueba que a) lleva mucho tiempo, b) estará sujeto a algunos problemas comunes relacionados con los problemas de tiempo de renderizado de la página, y c) es tal que si falla, no le dará un método conciso y \u0026ldquo;fácil de ver\u0026rdquo; para diagnosticar lo que salió mal.\nLa estrategia preferida para probar este escenario sería dividirlo en una serie de pruebas rápidas e independientes, cada una de las cuales tiene una \u0026ldquo;razón\u0026rdquo; para existir.\nSupongamos que quieres probar el segundo paso: Configurando tu unicornio. Deberá realizar las siguientes acciones:\n Crea una cuenta Configurar un unicornio  Tenga en cuenta que estamos omitiendo el resto de estos pasos, probaremos el resto del flujo de trabajo en otros casos de prueba pequeños y discretos, una vez que hayamos terminado con este.\nPara comenzar, debe crear una cuenta. Aquí tienes algunas opciones a resolver:\n ¿Quieres usar una cuenta existente? ¿Quieres crear una nueva cuenta? ¿Hay alguna propiedad especial de dicho usuario que deba tenerse en cuenta antes de que comience la configuración?  Independientemente de cómo responda estas preguntas, la solución es hacer que forme parte del flujo de \u0026ldquo;configurar los datos\u0026rdquo; de la prueba –si Larry ha expuesto una API que le permite a usted (o cualquier persona) crear y actualizar cuentas de usuario, asegúrese de usarla para responder esta situación– si es posible, lo deseable es iniciar el navegador solo después de tener un usuario disponible, cuyas credenciales le permitan iniciar sesión.\nSi cada prueba para cada flujo de trabajo comienza con la creación de una cuenta de usuario, se agregarán muchos segundos a la ejecución de cada prueba. Llamar a una API y hablar con una base de datos son operaciones rápidas y sin interfaz gráfica (headless) que no requieren el costoso proceso de abrir un navegador, navegar a las páginas correctas, hacer clic y esperar a que se envíen los formularios, etc.\nIdealmente, puede abordar esta fase de configuración en una línea de código, que se ejecutará antes de que se inicie cualquier navegador:\nJava Python C# Ruby JavaScript Kotlin // Cree un usuario que tenga permisos de solo lectura: puede configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se cree el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente; ni siquiera necesita // conocerlos. User user = UserFactory.createCommonUser(); // Este método se define en otra parte.  // Inicie sesión como este usuario. // Iniciar sesión en este sitio lo lleva a su página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // El método loginAs devuelve el objeto AccountPage, lo que le permite // realiza acciones desde AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Cree un usuario que tenga permisos de solo lectura: puede configurar un unicornio, # pero no tienen configurada la información de pago, ni tienen # Privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico # la dirección y la contraseña se generan aleatoriamente; ni siquiera necesita # conocerlos. user = user_factory.create_common_user() #Este método se define en otra parte. # Inicie sesión como este usuario. # Iniciar sesión en este sitio lo lleva a su página personal \u0026#34;Mi cuenta\u0026#34;, por lo que # El objeto loginAs devuelve el objeto AccountPage, lo que le permite # realizar acciones desde la página de cuenta. account_page = login_as(user.get_email(), user.get_password())   // Todavía no tenemos una muestra de código C# - ayúdenos y genere un PR (pull request)    # Todavía no tenemos una muestra de código en Ruby - ayúdenos y genere un PR (pull request)   // Todavía no tenemos una muestra de código JavaScript - ayúdenos y genere un PR (pull request)    // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     Como se puede imaginar, la UserFactory se puede ampliar para proporcionar métodos como createAdminUser() y createUserWithPayment(). El punto es que estas dos líneas de código no le distraigan del objetivo final de esta prueba: configurar un unicornio.\nLas complejidades del Modelo de objeto de página (Page Object Model) se analizarán en capítulos posteriores, pero presentaremos el concepto aquí:\nSus pruebas deben estar compuestas de acciones, realizadas desde el punto de vista del usuario, dentro del contexto de las páginas del sitio. Estas páginas se almacenan como objetos, que contendrán información específica sobre cómo se compone la página web y cómo se realizan las acciones, muy poco de lo que debería preocuparte como tester.\n¿Qué tipo de unicornio quieres? Es posible que desee rosa, pero no necesariamente. El morado ha sido muy popular últimamente. ¿El necesita gafas de sol? ¿Tatuajes de estrellas? Estas elecciones, si bien son difíciles, son su principal preocupación como probador: debe asegurarse de que su centro de cumplimiento de pedidos envíe el unicornio correcto a la persona adecuada, y eso comienza con estas elecciones.\nObserve que en ninguna parte de ese párrafo hablamos de botones, campos, menús desplegables, botones de opción o formularios web. ¡Tampoco debería hacerlo sus pruebas! Lo deseable es escribir el código como el usuario que intenta resolver su problema. Aquí hay una forma de hacerlo (continuando con el ejemplo anterior):\nJava Python C# Ruby JavaScript Kotlin // El Unicornio es un Objeto de nivel superior: tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de cualquier manera. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Como ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar real donde configuras unicornios. Llamando al método \u0026#34;addUnicorn\u0026#34; // nos lleva allí. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Ahora que estamos en AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; // al método createUnicorn(). Este método tomará los atributos de Sparkles, // llena el formulario y hace clic en el botón enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # El Unicornio es un Objeto de nivel superior: tiene atributos, que se establecen aquí. # Esto solo almacena los valores; no llena ningún formulario web ni interactúa # con el navegador de cualquier manera. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Como ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder a # lugar real donde se configuran los unicornios. Llamando al método \u0026#34;addUnicorn\u0026#34; # nos lleva allí. add_unicorn_page = account_page.add_unicorn() # Ahora que estamos en AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a # su método createUnicorn(). Este método tomará los atributos de Sparkles, # completará el formulario y haga clic en enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // Todavía no tenemos una muestra de código en C# - ayúdanos y genera un PR (pull request)    # Todavía no tenemos una muestra de código en Ruby - ayúdanos y genera un PR (pull request)   // Todavía no tenemos una muestra de código en JavaScript - ayúdanos y genera un PR (pull request)    // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. val addUnicornPage = accountPage.addUnicorn() // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Ahora que ha configurado su unicornio, debe continuar al paso 3: asegurarse de que realmente funcionó.\nJava Python C# Ruby JavaScript Kotlin // El método exist() de UnicornConfirmationPage tomará Sparkles // objeto: una especificación de los atributos que desea ver y compararlos // con los campos en la página. Assert.assertTrue(\u0026#34;Deben haberse creado Sparkles, con todos los atributos intactos.\u0026#34;, unicornConfirmationPage.exists(sparkles));   # El método exist() de UnicornConfirmationPage tomará Sparkles # objeto: una especificación de los atributos que desea ver y compararlos # con los campos en la página. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Todavía no tenemos una muestra de código en Ruby - ayúdanos y genera un PR (pull request)   // Todavía no tenemos una muestra de código en JavaScript - ayúdanos y genera un PR (pull request)    // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. //CHECK Boris assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     Tenga en cuenta que el tester aún no ha hecho nada más que hablar de unicornios en este código, sin botones, sin localizadores, sin controles del navegador. Este método de \u0026ldquo;modelado\u0026rdquo; de la aplicación le permite mantener estos comandos de nivel de prueba en su lugar y sin cambios, incluso si Larry decide la próxima semana que ya no le gusta Ruby-on-Rails y decide volver a implementar todo el sitio con las librerías más recientes de Haskell y con un front-end en Fortran.\nLos objetos de su página requerirán un pequeño mantenimiento para cumplir con el rediseño del sitio, pero estas pruebas seguirán siendo las mismas. Tomando este diseño básico, querrá continuar con sus flujos de trabajo con la menor cantidad posible de pasos orientados hacia el navegador. Su próximo flujo de trabajo implicará agregar un unicornio al carrito de compras. Probablemente requeriá muchas iteraciones de esta prueba para asegurarse de que el carrito mantenga su estado correctamente: ¿Hay más de un unicornio en el carrito antes de comenzar? ¿Cuántos pueden caber en el carrito de compras? Si crea más de uno con el mismo nombre o características, ¿se romperá? ¿Conservará solo el existente o agregará otro?\nCada vez que se mueva por el flujo de trabajo, debe intentar evitar tener que crear una cuenta, iniciar sesión como usuario y configurar el unicornio. Idealmente, podrá crear una cuenta y preconfigurar un unicornio a través de la API o la base de datos. Luego, todo lo que tiene que hacer es iniciar sesión como usuario, localizar Sparkles y agregarla al carrito.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/working_with_colours/",
	"title": "Trabajando con colores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n You will occasionally want to validate the colour of something as part of your tests; the problem is that colour definitions on the web are not constant. Would it not be nice if there was an easy way to compare a HEX representation of a colour with a RGB representation of a colour, or a RGBA representation of a colour with a HSLA representation of a colour?\nWorry not. There is a solution: the Color class!\nFirst of all, you will need to import the class:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.Color    You can now start creating colour objects. Every colour object will need to be created from a string representation of your colour. Supported colour representations are:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     The Color class also supports all of the base colour definitions specified in http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     Sometimes browsers will return a colour value of \u0026ldquo;transparent\u0026rdquo; if no colour has been set on an element. The Color class also supports this:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     You can now safely query an element to get its colour/background colour knowing that any response will be correctly parsed and converted into a valid Color object:\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;); Color loginButtonBackgroundColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;);   login_button_colour = driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;) login_button_background_colour = driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;);   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    login_button_colour = driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;) login_button_background_colour = driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;);   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val loginButtonColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;) val loginButtonBackgroundColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;)     You can then directly compare colour objects:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour == HOTPINK)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     Or you can convert the colour into one of the following formats and perform a static validation:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     Colours are no longer a problem.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/remote_webdriver/remote_webdriver_client/",
	"title": "WebDriver remoto - cliente",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n First, we need to connect to the RemoteWebDriver. We do this by pointing the URL to the address of the server running our tests. In order to customize our configuration, we set desired capabilities. Below is an example of instantiating a remote WebDriver object pointing to our remote web server, www.example.com, running our tests on Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     To further customize our test configuration, we can add other desired capabilities.\nDesired capabilities Desired capabilities can be expanded further. All remote Webdriver capabilities are sent through JsonWireProtocol. For a list of configurable capabilities, and more information on JsonWireProtocol, please visit the documentation here.\nFor example, suppose you wanted to run Chrome on Windows XP, using Chrome version 67:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     Local file detector The Local File Detector allows the transfer of files from the client machine to the remote server. For example, if a test needs to upload a file to a web application, a remote WebDriver can automatically transfer the file from the local machine to the remote web server during runtime. This allows the file to be uploaded from the remote machine running the test. It is not enabled by default and can be enabled in the following way:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    driver.setFileDetector(new LocalFileDetector())     Once the above code is defined, you can upload a file in your test in the following way:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/setting_up_your_own_grid/",
	"title": "Configurando tu propio Grid",
	"tags": [],
	"description": "",
	"content": " Para usar Selenium Grid, debe mantener su propia infraestructura para los nodos. Como esto puede ser un esfuerzo demandante e intenso, muchas organizaciones utilizan proveedores de IaaS como Amazon EC2 y Google Compute para proporcionar esta infraestructura.\nOtras opciones incluyen el uso de proveedores como Sauce Labs o Testing Bot que proporcionan un Selenium Grid como servicio en la nube. Ciertamente, también es posible ejecutar nodos en su infraestructura propia. Este capítulo entrará en detalles sobre la opción de ejecutar su propia grid, de manera completa con su propia infraestructura de nodos.\nInicio rápido Este ejemplo le mostrará cómo iniciar Selenium 2 Grid Hub y registrar un nodo WebDriver y un nodo heredado Selenium 1 RC. También le mostraremos cómo llamar a la grid desde Java. El concentrador (hub) y los nodos se muestran aquí ejecutándose en la misma máquina, pero, por supuesto, puede copiar el servidor independiente de Selenium (selenium-server-standalone) en varias máquinas.\nEl paquete selenium-server-standalone incluye el hub, WebDriver y el RC heredado necesario para ejecutar la Grid, ant ya no es necesario. Puede descargar el selenium-server-standalone-.jar desde https://selenium.dev/downloads/.\nPaso 1: Inicie el Hub El Hub es el punto central que recibirá las solicitudes de prueba y las distribuirá a los nodos correctos. La distribución se realiza en función de las capacidades, lo que significa que una prueba que requiere un conjunto de capacidades (capabilities) solo se distribuirá a los nodos que ofrecen ese conjunto o subconjunto de capacidades.\nDebido a que las capacidades deseadas de una prueba son exactamente lo que el nombre implica \u0026ldquo;deseadas\u0026rdquo;, el concentrador no puede garantizar que localizará un nodo que coincida completamente con el conjunto de capacidades deseadas solicitado.\nAbra una consola del sistema y navegue hasta el directorio donde copió el archivo selenium-server-standalone.jar. Inicie el concentrador pasando el indicador -role hub al servidor independiente:\njava -jar selenium-server-standalone.jar -role hub El Hub escuchará el puerto 4444 por defecto. Puede ver el estado del concentrador abriendo una ventana del navegador y navegando a http://localhost:4444/grid/console.\nPara cambiar el puerto predeterminado, puede agregar el indicador opcional -port con un número entero que representa el puerto para escuchar cuando ejecuta el comando. Además, todas las otras opciones que ve en el archivo de configuración JSON (que se ve a continuación) son posibles indicadores de línea de comandos.\nCiertamente puede hacerlo solo con el comando simple que se muestra arriba, pero si necesita una configuración más avanzada, también puede especificar un archivo de configuración de formato JSON para configurar el concentrador cuando lo inicie. Puede hacerlo así:\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug A continuación verá un ejemplo de un archivo hubConfig.json. Entraremos en más detalles sobre cómo proporcionar archivos de configuración de nodos en el paso 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Step 2: Start the Nodes Independientemente de si desea ejecutar una grid con la nueva funcionalidad WebDriver, o una grid con la funcionalidad Selenium 1 RC, o ambas al mismo tiempo, utilice el mismo archivo selenium-server-standalone.jar para iniciar los nodos:\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 Si no se especifica un puerto a través de la argumento -port, se elegirá un puerto libre. Puede ejecutar múltiples nodos en una máquina, pero si lo hace, debe conocer los recursos de memoria de su sistema y los problemas con las capturas de pantalla si sus pruebas los toman.\nConfiguración de Nodo con opciones Como se mencionó, para la compatibilidad con versiones anteriores, los roles \u0026ldquo;wd\u0026rdquo; y \u0026ldquo;rc\u0026rdquo; siguen siendo un subconjunto válido del rol \u0026ldquo;node\u0026rdquo;. Pero esos roles limitan los tipos de conexiones remotas a su API correspondiente, mientras que \u0026ldquo;node\u0026rdquo; permite conexiones remotas RC y WebDriver.\nAl pasar las propiedades de JVM (usando el indicador -D antes del argumento -jar) también en la línea de comando, estas serán recogidas y propagadas a los nodos:\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfiguración de nodo con JSON También puede iniciar nodos de grid configurados con un archivo de configuración JSON\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json Y este es un ejemplo del archivo nodeConfig.json:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } Una nota sobre la argumento -host\nTanto para el concentrador como para el nodo, si no se especifica el indicador -host, se usará0.0.0.0 por defecto. Esto se unirá a todas las interfaces IPv4 públicas (sin loopback) de la máquina. Si tiene una configuración de red especial o algún componente que cree interfaces de red adicionales, se recomienda establecer el indicador -host con un valor que permita que se pueda acceder al concentrador / nodo desde una máquina diferente.\nEspecificando el puerto El puerto TCP / IP predeterminado utilizado por el concentrador es 4444. Si necesita cambiar el puerto, utilice las configuraciones mencionadas anteriormente.\nSolución de problemas Uso del archivo de registro Para la resolución de problemas avanzada, puede especificar el archivo de registro para almacenar los mensajes del sistema. Para eso, inicie Selenium GRID hub o nodo con el argumento -log. Por favor vea el siguiente ejemplo:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Use su editor de texto favorito para abrir el archivo de registro (log.txt en el ejemplo anterior) para encontrar registros de \u0026ldquo;ERROR\u0026rdquo; si tiene problemas.\nUsando el argumento -debug También puede usar el argumento -debug para imprimir registros de depuración en la consola. Para eso, inicie Selenium Grid Hub o Node con el argumento -debug. Por favor vea el siguiente ejemplo\njava -jar selenium-server-standalone.jar -role hub -debug Advertencia Selenium Grid debe protegerse del acceso externo mediante los permisos de firewall adecuados. Si no protege su Grid, podría ocurrir uno o más de los siguientes casos: * Usted proporciona acceso abierto a su infraestructura Grid * Permitir que terceros accedan a aplicaciones y archivos web internos * Permites que terceros ejecuten binarios personalizados\nConsulte esta publicación de blog en Detectify que ofrece una buena visión general de cómo se puede utilizar incorrectamente una grid expuesta públicamente: Inglés: No deje la grid abierta.\nDocker Selenium Docker proporciona una forma conveniente de aprovisionar y escalar la infraestructura de Selenium Grid en una unidad conocida como contenedor. Los contenedores son unidades de software estandarizadas que contienen todo lo necesario para ejecutar la aplicación deseada, incluidas todas las dependencias de manera confiable y repetible en diferentes máquinas.\nEl proyecto Selenium mantiene un conjunto de imágenes de Docker que puede descargar y ejecutar para que una grid de trabajo funcione rápidamente. Los nodos están disponibles para Firefox y Chrome. Los detalles completos sobre cómo aprovisionar una grid se pueden encontrar en el repositorio Docker Selenium.\nRequisito previo El único requisito para ejecutar un Grid es tener Docker instalado y funcionando. Instalar Docker.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/http_response_codes/",
	"title": "Códigos de respuesta HTTP",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n For some browser configurations in Selenium RC, Selenium acted as a proxy between the browser and the site being automated. This meant that all browser traffic passed through Selenium could be captured or manipulated. The captureNetworkTraffic() method purported to capture all of the network traffic between the browser and the site being automated, including HTTP response codes.\nSelenium WebDriver is a completely different approach to browser automation, preferring to act more like a user and this is represented in the way you write tests with WebDriver. In automated functional testing, checking the status code is not a particularly important detail of a test\u0026rsquo;s failure; the steps that preceded it are more important.\nThe browser will always represent the HTTP status code, imagine for example a 404 or a 500 error page. A simple way to “fail fast” when you encounter one of these error pages is to check the page title or content of a reliable point (e.g. the \u0026lt;h1\u0026gt; tag) after every page load. If you are using the page object model, you can include this check in your class constructor or similar point where the page load is expected. Occasionally, the HTTP code may even be represented in the browser\u0026rsquo;s error page and you could use WebDriver to read this and improve your debugging output.\nChecking the webpage itself is in line with WebDriver\u0026rsquo;s ideal practice of representing and asserting upon the user’s view of the website.\nIf you insist, an advanced solution to capturing HTTP status codes is to replicate the behaviour of Selenium RC by using a proxy. WebDriver API provides the ability to set a proxy for the browser, and there are a number of proxies that will programmatically allow you to manipulate the contents of requests sent to and received from the web server. Using a proxy lets you decide how you want to respond to redirection response codes. Additionally, not every browser makes the response codes available to WebDriver, so opting to use a proxy allows you to have a solution that works for every browser.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/generating_application_state/",
	"title": "Generar el estado de la aplicación",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Selenium should not be used to prepare a test case. All repetitive actions and preparations for a test case, should be done through other methods. For example, most web UIs have authentication (e.g. a login form). Eliminating logging in via web browser before every test will improve both the speed and stability of the test. A method should be created to gain access to the AUT* (e.g. using an API to login and set a cookie). Also, creating methods to pre-load data for testing should not be done using Selenium. As mentioned previously, existing APIs should be leveraged to create data for the AUT*.\n*AUT: Application under test\n"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/",
	"title": "Instalación de Selenium",
	"tags": [],
	"description": "",
	"content": " Instalación de Selenium La configuración de Selenium es bastante diferente de la configuración de otras herramientas comerciales. Para usar Selenium en su proyecto de automatización, necesita instalar las librerías para el lenguaje de programación de su elección. Además, necesitará los binarios del WebDriver para los navegadores en los que desea automatizar y ejecutar la prueba.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/installing_standalone_server/",
	"title": "Instalación del servidor Standalone",
	"tags": [],
	"description": "",
	"content": "Si planeas usar Grid debes descargar el fichero selenium-server-standalone JAR. El jar selenium-server-standalone nunca se carga, pero todos los componentes están disponibles a través de selenium-server. El standalone JAR contiene todo, incluso el servidor remoto de Selenium y los enlaces del lado del cliente. Ésto quiere decir que si usas el selenium-server-standalone jar en tu proyecto, no tienes que añadir selenium-java o un jar de navegador específico.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/locating_elements/",
	"title": "Localizando elementos",
	"tags": [],
	"description": "",
	"content": " Localizando un elemento Una de las técnicas más fundamentales por aprender al usar WebDriver es cómo encontrar elementos en la página. WebDriver ofrece varios tipos de selectores integrados, entre ellos encontrar un elemento por su atributo ID:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element_by_id(\u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   driver.find_element(id: \u0026#34;cheese\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     Como se ve en el ejemplo, la localización de elementos en WebDriver se realiza en el objeto de instancia WebDriver. El método findElement(By) devuelve otro tipo de objeto fundamental, el WebElement.\n WebDriver representa al navegador. WebElement representa a un nodo DOM particular (un control, por ejemplo, un enlace o campo de entrada, etc.).  Una vez que tenga la referencia a un elemento web que se ha \u0026ldquo;encontrado\u0026rdquo;, puede reducir el alcance de su búsqueda utilizando la misma llamada en esa instancia de objeto:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element_by_id(\u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements(id: \u0026#34;cheddar\u0026#34;)   const cheese = await driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = await cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     Usted puede hacer esto porque los tipos WebDriver y WebElement implementan la interfaz SearchContext. En WebDriver, esto se conoce como interfaz basada en roles. Las interfaces basadas en roles le permiten determinar si una implementación de controlador particular admite una característica determinada. Estas interfaces están claramente definidas y tratan de cumplir con tener un solo rol de responsabilidad. Puede leer más sobre el diseño de WebDriver y qué roles se admiten en qué controladores en Alguna otra sección que debe nombrarse. En consecuencia, la interfaz By utilizada anteriormente también admite una serie de estrategias de localización adicionales. Una búsqueda anidada podría no ser la estrategia de ubicación más efectiva, ya que requiere que se envíen dos comandos separados al navegador; primero buscando en el DOM un elemento con ID \u0026ldquo;cheese\u0026rdquo;, luego una búsqueda de \u0026ldquo;cheddar\u0026rdquo; en un contexto restringido.\nPara mejorar ligeramente el rendimiento, deberíamos tratar de usar un localizador más específico: WebDriver admite la búsqueda de elementos mediante localizadores CSS, lo que nos permite combinar los dos localizadores anteriores en una sola búsqueda:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese #cheddar\u0026#34;)   const cheddar = await driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     Localizando múltiples elementos Es posible que el documento con el que estamos trabajando tenga una lista ordenada de quesos que más nos gustan:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Dado que más queso es indiscutiblemente mejor, y sería engorroso tener que recuperar cada uno de los elementos individualmente, una técnica superior para recuperar queso es utilizar la versión pluralizada findElements(By). Este método devuelve una colección de elementos web. Si solo se encuentra un elemento, aún devolverá una colección (de un elemento). Si ningún elemento coincide con el localizador, se devolverá una lista vacía.\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#34;#cheese li\u0026#34;)   const muchoCheese = await driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     Estrategias de localización de elementos Hay ocho estrategias diferentes de ubicación de elementos integrados en WebDriver:\n   Localizador Descripción     class name Localiza elementos cuyo nombre de clase contiene el valor de búsqueda (no se permiten nombres de clase compuestos)   css selector Localiza elementos que coinciden con un selector CSS   id Localiza elementos cuyo atributo ID coincide con el valor de búsqueda   name Localiza elementos cuyo atributo NAME coincide con el valor de búsqueda   link text Localiza elementos de hipervínculo cuyo texto visible coincide con el valor de búsqueda   partial link text Localiza elementos de vínculo o enlace cuyo texto visible coincide con el valor de búsqueda   tag name Localiza elementos cuyo nombre de etiqueta coincide con el valor de búsqueda   xpath Localiza elementos que coinciden con una expresión XPath    Consejos para usar selectores En general, si las ID de HTML están disponibles, son únicas y predecibles de manera consistente, son el método preferido para ubicar un elemento en una página. Tienden a funcionar muy rápidamente y renuncian a mucho procesamiento que viene con recorridos DOM complicados.\nSi las ID únicas no están disponibles, un selector CSS bien escrito es el método preferido para localizar un elemento. XPath funciona tan bien como los selectores CSS, pero la sintaxis es complicada y con frecuencia difícil de depurar. Aunque los selectores XPath son muy flexibles, generalmente no son probados por los proveedores de navegadores y tienden a ser bastante lentos.\nLas estrategias de selección basadas en texto de enlace y texto parcial de enlace tienen inconvenientes en el sentido de que solo funcionan en elementos de enlace. Además, llaman a los selectores XPath internamente en WebDriver.\nLa etiqueta nombre (name) puede ser una forma peligrosa de localizar elementos. Con frecuencia hay varios elementos de la misma etiqueta presentes en la página. Esto es principalmente útil cuando se llama al método findElements(By) que devuelve una colección de elementos.\nLa recomendación es mantener sus localizadores lo más compactos y legibles posible. Pedirle al WebDriver que atraviese la estructura DOM es una operación costosa, y cuanto más pueda reducir el alcance de su búsqueda, mejor.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/browser_manipulation/",
	"title": "Manipulación de Navegadores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.getCurrentUrl();    Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward();    Refresh Refresh the current page:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.getTitle()    Windows and tabs Get window handle WebDriver does not make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.getWindowHandle()    Switching windows or tabs Clicking a link which opens in a new window will focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io/docs/wd.html\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element_by_link_text(\u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;Selenium documentation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Quit will:  Close all the windows and tabs associated with that WebDriver session Close the browser process Close the background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)   Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, Webdriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io/docs/iframe.html\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it wasn\u0026rsquo;t for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element_by_css_selector(\u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = await driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().getSize().getWidth() val height = driver.manage().window().getSize().getHeight() //Or store the dimensions and query them later val size = driver.manage().window().getSize() val width1 = size.getWidth() val height1 = size.getHeight()     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size(Dimension(1024, 768))   \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x int y1 = position.y     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     Maximise window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/types_of_testing/",
	"title": "Tipos de pruebas",
	"tags": [],
	"description": "",
	"content": " Prueba de aceptación Este tipo de prueba se realiza para determinar si la característica de un producto cumple con sus requisitos. Esto generalmente implica la retroalimentación o especificación del cliente.\nPara aplicaciones web, la automatización de este tipo de prueba se puede hacer directamente con Selenium simulando el comportamiento esperado del usuario. Esta simulación se puede realizar mediante grabación / reproducción o mediante los diferentes lenguajes de programación admitidos, tal como se explica en esta documentación. Nota: Las pruebas de aceptación son un subtipo de pruebas funcionales, a las que algunas personas también pueden referirse.\nPrueba funcional Este tipo de prueba se realiza para determinar si la característica de un producto funciona correctamente, sin problemas. Esto generalmente incluye: que las pruebas funcionen sin errores (páginas 404, excepciones \u0026hellip;), de manera utilizable (redirecciones correctas), de manera accesible y con sus especificaciones (ver pruebas de aceptación más arriba).\nPara aplicaciones web, la automatización de estas pruebas se puede hacer directamente con Selenium simulando los retornos esperados. Esta simulación podría realizarse mediante grabación / reproducción o mediante los diferentes lenguajes admitidos, tal como se explica en esta documentación.\nPruebas de rendimiento o desempeño Como su nombre lo indica, se realizan pruebas de rendimiento para medir el rendimiento de una aplicación.\nHay dos subtipos principales para las pruebas de rendimiento:\nPrueba de carga La prueba de carga se realiza para verificar qué tan bien funciona la aplicación bajo diferentes cargas definidas (generalmente un número particular de usuarios conectados a la vez).\nPruebas de estrés o esfuerzo La prueba de esfuerzo se realiza para verificar qué tan bien funciona la aplicación bajo estrés (o por encima de la carga máxima soportada).\nEn general, las pruebas de rendimiento se realizan mediante la ejecución de una serie de pruebas escritas de Selenium que simulan a diferentes usuarios que acceden a una función particular en la aplicación web y recuperan algunas mediciones significativas.\nEn general, esto lo hacen otras herramientas que recuperan las métricas. Una de esas herramientas es JMeter.\nPara una aplicación web, los detalles a medir incluyen: rendimiento (throughput), latencia, pérdida de datos, tiempos de carga de componentes individuales \u0026hellip;\nNota: Todos los navegadores tienen una pestaña de rendimiento en la sección de herramientas de desarrolladores (accesible presionando F12).\nNota 2: es un subtipo de pruebas no funcionales ya que generalmente se mide por sistema y no por función / característica.\nPruebas de regresión Esta prueba generalmente se realiza después de un cambio, corrección o adición de características.\nPara garantizar que el cambio no haya roto ninguna de las funciones existentes, algunas pruebas ya ejecutadas se ejecutan nuevamente. El conjunto de pruebas ejecutadas de nuevo puede ser completo o parcial y puede incluir varios tipos diferentes, según la aplicación y el equipo de desarrollo.\nDesarrollo guiado por pruebas (TDD) En lugar de un tipo de prueba per se, TDD es una metodología de desarrollo iterativa en la que las pruebas guían el diseño de una característica. Cada ciclo comienza creando un conjunto de pruebas unitarias que la característica debe pasar (que debe fallar la primera vez que se ejecuta).Después de esto, se lleva a cabo el desarrollo para que las pruebas pasen. Las pruebas se ejecutan nuevamente comenzando otro ciclo y este proceso continúa hasta que todas las pruebas hayan pasado.\nEl objetivo es acelerar el desarrollo de una aplicación basada en el hecho de que los defectos son menos costosos cuanto antes se encuentran.\nDesarrollo impulsado por el comportamiento (BDD) BDD es también una metodología de desarrollo iterativa basada en el anterior (TDD) en la que el objetivo es involucrar a todas las partes en el desarrollo de una aplicación.\nCada ciclo comienza creando alguna especificación (que debería fallar). Luego se crean las pruebas unitarias fallidas (que también deberían fallar) y luego se crea el desarrollo. Este ciclo se repite hasta que pase todo tipo de pruebas.\nPara hacerlo, se utiliza un lenguaje de especificación. Debe ser entendible por todas las partes y simple, estándar y explícito. La mayoría de las herramientas usan Gherkin como este lenguaje.\nEl objetivo es ser capaz de detectar incluso más errores que TDD al enfocarse también en posibles errores de aceptación y hacer que la comunicación entre las partes sea más fluida.\nActualmente hay un conjunto de herramientas disponibles para escribir las especificaciones y combinarlas con funciones de código, como Cucumber o SpecFlow.\nSe ha creado un conjunto de herramientas sobre Selenium para que este proceso sea aún más rápido al transformar directamente las especificaciones de BDD en código ejecutable. Algunos de estos son: JBehave, Capybara y Robot Framework.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/working_with_select_elements/",
	"title": "Trabajando con elementos select",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Select elements can require quite a bit of boiler plate code to automate. To reduce this and make your tests cleaner, there is a Select class in the Selenium support package. To use it, you will need the following import statement:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.ui.Select     You are then able to create a Select object using a WebElement that references a \u0026lt;select\u0026gt; element.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element_by_id(\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     The Select object will now give you a series of commands that allow you to interact with a \u0026lt;select\u0026gt; element. First of all, there are different ways of selecting an option from the \u0026lt;select\u0026gt; element.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; There are three ways to select the first option from the above element:\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     You can then check which options are selected by using:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     Or you may just be interested in what \u0026lt;option\u0026gt; elements the \u0026lt;select\u0026gt; element contains:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     If you want to deselect any elements, you now have four options:\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     Finally, some \u0026lt;select\u0026gt; elements allow you to select more than one option. You can find out if your \u0026lt;select\u0026gt; element is one of these by using:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    does_this_allow_multiple_selections = select_object.multiple?   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "Acciones en detalle del mouse y teclado",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Suppose you have an arbitrary web element e:\nJava Python C# Ruby JavaScript Kotlin WebElement e = driver.findElement(By.id(\u0026#34;testElement\u0026#34;));   e = driver.find_element_by_id(\u0026#34;testElement\u0026#34;)   IWebElement e = driver.FindElement(By.Id(\u0026#34;testElement\u0026#34;));   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val element = driver.findElement(By.id(\u0026#34;testElement\u0026#34;))     You can simulate mouse clicking on e if it is visible and has a height and width that are greater than 0:\nJava Python C# Ruby JavaScript Kotlin e.click();   e.click()   e.Click();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    e.click()     Moreover, it is possible to mimic hovering of the cursor over e. In order to do so, you will need the following import statement:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.interactions.Actions;   from selenium.webdriver import ActionChains   using OpenQA.Selenium.Interactions;   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.interactions.Actions     With this statement in place, you can now move over the element in question:\nJava Python C# Ruby JavaScript Kotlin Actions actions = new Actions(driver); actions.moveToElement(e); actions.perform();   actions = ActionChains(driver) actions.move_to_element(e) actions.perform()   Actions actions = new Actions(driver); actions.MoveToElement(e); actions.Perform();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val actions = Actions(driver) actions.moveToElement(e); actions.perform();     If e is an input or textarea element, the following keyboard actions can be carried out:\n Enter a sequence of characters in e:  Java Python C# Ruby JavaScript Kotlin e.sendKeys(\u0026#34;Test\u0026#34;);   e.send_keys(\u0026#34;Test\u0026#34;)   e.SendKeys(\u0026#34;Test\u0026#34;);   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    e.sendKeys(\u0026#34;Test\u0026#34;)      Delete the text that is in e (if there is any):  Java Python C# Ruby JavaScript Kotlin e.clear();   e.clear()   e.Clear();   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    e.clear()     "
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/about_this_documentation/",
	"title": "Acerca de esta documentación",
	"tags": [],
	"description": "",
	"content": "Estos documentos, como el código en sí, son mantenidos al 100% por voluntarios dentro de la comunidad de Selenium. Muchos lo han estado usando desde su inicio, pero muchos más lo han estado usando desde hace poco y han dado su tiempo para ayudar a mejorar la experiencia de iniciación para los nuevos usuarios.\nSi hay un problema con la documentación, ¡queremos saberlo! La mejor manera de comunicar un problema es visitar https://github.com/seleniumhq/docs/issues y buscar para ver si el problema ya se ha archivado o no. Si no, ¡no dudes en abrir uno!\nMuchos miembros de la comunidad frecuentan el canal IRC #selenium en irc.freenode.net. ¡No dude en venir y hacer preguntas y si obtiene ayuda que cree que podría ser útil en estos documentos, asegúrese de agregar su contribución! Podemos actualizar estos documentos, pero es mucho más fácil para todos cuando recibimos contribuciones de fuera de los encargados normales.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Ejecutando acciones en la AUT*",
	"tags": [],
	"description": "",
	"content": " Puede establecer el texto de un elemento utilizando el método sendKeys de la siguiente manera:\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element_by_name(\u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     Algunas aplicaciones web usan bibliotecas JavaScript para agregar la funcionalidad de arrastrar y soltar. El siguiente es un ejemplo básico de arrastrar un elemento a otro elemento:\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element_by_id(\u0026#34;source\u0026#34;) target = driver.find_element_by_id(\u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = await driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = await driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     Al hacer clic en un elemento Puede hacer clic en un elemento utilizando el método de clic:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element_by_css_selector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     *AUT: Aplicación bajo pruebas (Application under test en inglés)\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/waits/",
	"title": "Esperas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n WebDriver can generally be said to have a blocking API. Because it is an out-of-process library that instructs the browser what to do, and because the web platform has an intrinsically asynchronous nature, WebDriver doesn\u0026rsquo;t track the active, real-time state of the DOM. This comes with some challenges that we will discuss here.\nFrom experience, most intermittents that arise from use of Selenium and WebDriver are connected to race conditions that occur between the browser and the user\u0026rsquo;s instructions. An example could be that the user instructs the browser to navigate to a page, then gets a no such element error when trying to find an element.\nConsider the following document:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; The WebDriver instructions might look innocent enough:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = await driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     The issue here is that the default page load strategy used in WebDriver listens for the document.readyState to change to \u0026quot;complete\u0026quot; before returning from the call to navigate. Because the p element is added after the document has completed loading, this WebDriver script might be intermittent. It “might” be intermittent because no guarantees can be made about elements or events that trigger asynchronously without explicitly waiting—or blocking—on those events.\nFortunately, using the normal instruction set available on the WebElement interface—such as WebElement.click and _WebElement.sendKeys_—are guaranteed to be synchronous, in that the function calls won\u0026rsquo;t return (or the callback won\u0026rsquo;t trigger in callback-style languages) until the command has been completed in the browser. The advanced user interaction APIs, Keyboard and Mouse, are exceptions as they are explicitly intended as “do what I say” asynchronous commands.\nWaiting is having the automated task execution elapse a certain amount of time before continuing with the next step.\nTo overcome the problem of race conditions between the browser and your WebDriver script, most Selenium clients ship with a wait package. When employing a wait, you are using what is commonly referred to as an explicit wait.\nExplicit wait Explicit waits are available to Selenium clients for imperative, procedural languages. They allow your code to halt program execution, or freeze the thread, until the condition you pass it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed. This means that for as long as the condition returns a falsy value, it will keep trying and waiting.\nSince explicit waits allow you to wait for a condition to occur, they make a good fit for synchronising the state between the browser and its DOM, and your WebDriver script.\nTo remedy our buggy instruction set from earlier, we could employ a wait to have the findElement call wait until the dynamically added element from the script has been added to the DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, 10) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = await driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, 10) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     We pass in the condition as a function reference that the wait will run repeatedly until its return value is truthy. A “truthful” return value is anything that evaluates to boolean true in the language at hand, such as a string, number, a boolean, an object (including a WebElement), or a populated (non-empty) sequence or list. That means an empty list evaluates to false. When the condition is truthful and the blocking wait is aborted, the return value from the condition becomes the return value of the wait.\nWith this knowledge, and because the wait utility ignores no such element errors by default, we can refactor our instructions to be more concise:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, 3) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: return d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); } \u0026lt;section id=\u0026#34;rubycode2\u0026#34; class=\u0026#34;tab-panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;highlight\u0026#34;\u0026gt;\u0026lt;pre style=\u0026#34;color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4\u0026#34;\u0026gt;\u0026lt;code class=\u0026#34;language-ruby\u0026#34; data-lang=\u0026#34;ruby\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;color:#586e75\u0026#34;\u0026gt;# We don\u0026amp;#39;t have a Ruby code sample yet - Help us out and raise a PR \u0026lt;/span\u0026gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;javascriptcode2\u0026#34; class=\u0026#34;tab-panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;highlight\u0026#34;\u0026gt;\u0026lt;pre style=\u0026#34;color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4\u0026#34;\u0026gt;\u0026lt;code class=\u0026#34;language-javascript\u0026#34; data-lang=\u0026#34;javascript\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;color:#586e75\u0026#34;\u0026gt;// We don\u0026amp;#39;t have a JavaScript code sample yet - Help us out and raise a PR \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026#34;color:#586e75\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section id=\u0026#34;kotlincode2\u0026#34; class=\u0026#34;tab-panel\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;highlight\u0026#34;\u0026gt;\u0026lt;pre style=\u0026#34;color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4\u0026#34;\u0026gt;\u0026lt;code class=\u0026#34;language-kotlin\u0026#34; data-lang=\u0026#34;kotlin\u0026#34;\u0026gt; driver.\u0026lt;span style=\u0026#34;color:#719e07\u0026#34;\u0026gt;get\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026#34;color:#2aa198\u0026#34;\u0026gt;\u0026amp;#34;file:///race_condition.html\u0026amp;#34;\u0026lt;/span\u0026gt;) \u0026lt;span style=\u0026#34;color:#719e07\u0026#34;\u0026gt;val\u0026lt;/span\u0026gt; ele = WebDriverWait(getWebDriver(), \u0026lt;span style=\u0026#34;color:#2aa198\u0026#34;\u0026gt;10\u0026lt;/span\u0026gt;) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026lt;span style=\u0026#34;color:#2aa198\u0026#34;\u0026gt;\u0026amp;#34;p\u0026amp;#34;\u0026lt;/span\u0026gt;))) assert(ele.text == \u0026lt;span style=\u0026#34;color:#2aa198\u0026#34;\u0026gt;\u0026amp;#34;Hello from JavaScript!\u0026amp;#34;\u0026lt;/span\u0026gt;) \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt;   In that example, we pass in an anonymous function (but we could also define it explicitly as we did earlier so it may be reused). The first and only argument that is passed to our condition is always a reference to our driver object, _WebDriver_ (called `d` in the example). In a multi-threaded environment, you should be careful to operate on the driver reference passed in to the condition rather than the reference to the driver in the outer scope. Because the wait will swallow _no such element_ errors that are raised when the element isn't found, the condition will retry until the element is found. Then it will take the return value, a _WebElement_, and pass it back through to our script. If the condition fails, e.g. a truthful return value from the condition is never reached, the wait will throw/raise an error/exception called a _timeout error_. ### Options The wait condition can be customised to match your needs. Sometimes it's unnecessary to wait the full extent of the default timeout, as the penalty for not hitting a successful condition can be expensive. The wait lets you pass in an argument to override the timeout: Java Python C# Ruby JavaScript Kotlin //new WebDriverWait(driver,3).until(some_condition(WebElement)) new WebDriverWait(driver, 3).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    WebDriverWait(driver, 3).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     ### Expected conditions Because it's quite a common occurrence to have to synchronise the DOM and your instructions, most clients also come with a set of predefined _expected conditions_. As might be obvious by the name, they are conditions that are predefined for frequent wait operations. The conditions available in the different language bindings vary, but this is a non-exhaustive list of a few: * alert is present * element exists * element is visible * title contains * title is * element staleness * visible text You can refer to the API documentation for each client binding to find an exhaustive list of expected conditions: * Java's [org.openqa.selenium.support.ui.ExpectedConditions](//seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html) class * Python's [selenium.webdriver.support.expected_conditions](//seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html?highlight=expected) class * .NET's [OpenQA.Selenium.Support.UI.ExpectedConditions](//seleniumhq.github.io/selenium/docs/api/dotnet/html/T_OpenQA_Selenium_Support_UI_ExpectedConditions.html) type ## Implicit wait There is a second type of wait that is distinct from [explicit wait](#explicit-wait) called _implicit wait_. By implicitly waiting, WebDriver polls the DOM for a certain duration when trying to find _any_ element. This can be useful when certain elements on the webpage are not available immediately and need some time to load. Implicit waiting for elements to appear is disabled by default and will need to be manually enabled on a per-session basis. Mixing [explicit waits](#explicit-wait) and implicit waits will cause unintended consequences, namely waits sleeping for the maximum time even if the element is available or condition is true. *Warning:* Do not mix implicit and explicit waits. Doing so can cause unpredictable wait times. For example, setting an implicit wait of 10 seconds and an explicit wait of 15 seconds could cause a timeout to occur after 20 seconds. An implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0, meaning disabled. Once set, the implicit wait is set for the life of the session. Java Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element_by_id(\u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = await driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     ## FluentWait FluentWait instance defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition. Users may configure the wait to ignore specific types of exceptions whilst waiting, such as `NoSuchElementException` when searching for an element on the page. Java Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val wait = FluentWait\u0026lt;WebDriver\u0026gt;(getWebDriver()) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }       "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Gmail, email y Facebook logins",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n For multiple reasons, logging into sites like Gmail and Facebook using WebDriver is not recommended. Aside from being against the usage terms for these sites (where you risk having the account shut down), it is slow and unreliable.\nThe ideal practice is to use the APIs that email providers offer, or in the case of Facebook the developer tools service which exposes an API for creating test accounts, friends and so forth. Although using an API might seem like a bit of extra hard work, you will be paid back in speed, reliability, and stability. The API is also unlikely to change whereas webpages and HTML locators change often and require you to update your test framework.\nLogging in to third party sites using WebDriver at any point of your test increases the risk of your test failing because it makes your test longer. A general rule of thumb is that longer tests are more fragile and unreliable.\nWebDriver implementations that are W3C conformant also annotate the navigator object with a webdriver property so that Denial of Service attacks can be mitigated.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/mock_external_services/",
	"title": "Mock de servicios externos",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Eliminating the dependencies on external services will greatly improve the speed and stability of your tests.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/",
	"title": "Primeros pasos con WebDriver",
	"tags": [],
	"description": "",
	"content": " Primeros pasos con WebDriver Selenium admite la automatización de todos los principales navegadores del mercado mediante el uso del WebDriver. WebDriver es una API y un protocolo que define una interfaz de lenguaje neutral para controlar el comportamiento de los navegadores web. Cada navegador está respaldado por una implementación específica de WebDriver, llamada controlador (o driver). El controlador es el componente responsable de manipular el navegador, y maneja la comunicación hacia y desde Selenium y el navegador.\nEsta separación es parte de un esfuerzo consciente para que los proveedores de navegadores se hagan responsables de la implementación de sus navegadores. Selenium hace uso de estos controladores de terceros cuando es posible, pero también proporciona sus propios controladores mantenidos por el proyecto para los casos en que esto no pueda ser realizado.\nEl marco Selenium une todas estas piezas a través de una interfaz orientada al usuario que permite que los diferentes backends del navegador se utilicen de forma transparente, lo que permite la automatización entre navegadores (cross-browser) y plataformas cruzadas (cross-platform).\nSe pueden encontrar más detalles sobre los controladores en Driver Idiosyncrasies.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/support_classes/",
	"title": "Clases de apoyo",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/test_dependency/",
	"title": "Dependencia entre pruebas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n A common idea and misconception about automated testing is regarding a specific test order. Your tests should be able to run in any order, and not rely on other tests to complete in order to be successful.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/improved_reporting/",
	"title": "Mejores reportes",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Selenium is not designed to report on the status of test cases run. Taking advantage of the built-in reporting capabilities of unit test frameworks is a good start. Most unit test frameworks have reports that can generate xUnit or HTML formatted reports. xUnit reports are popular for importing results to a Continuous Integration (CI) server like Jenkins, Travis, Bamboo, etc. Here are some links for more information regarding report outputs for several languages. NUnit 3 Console Runner NUnit 3 Console Command Line xUnit getting test results in TeamCity xUnit getting test results in CruiseControl.NET xUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/working_with_web_elements/",
	"title": "Trabajando con elementos web",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": " WebDriver El cambio más grande en Selenium, recientemente, ha sido la inclusión de la API WebDriver. Manejar un navegador de forma nativa como lo haría un usuario localmente o en una máquina remota usando el servidor Selenium, marca un salto adelante en términos de automatización del navegador.\nSelenium WebDriver encaja en el mismo rol que RC, y ha incorporado los enlaces 1.x originales. Se refiere tanto a los enlaces de lenguaje como a las implementaciones del código de control del navegador individual. Esto se conoce comúnmente como WebDriver o, a veces, como Selenium 2.\nSelenium 1.0 + WebDriver = Selenium 2.0\n El WebDriver está diseñado en una interfaz de programación más simple y concisa junto con algunas limitaciones en la API Selenium-RC.\n El WebDriver es una API compacta orientada a objetos en comparación con Selenium 1.0.\n Este, comtrola al navegador de manera mucho más efectiva y supera las limitaciones de Selenium 1 que afectaron nuestra cobertura de prueba funcional, como la carga o descarga de archivos, ventanas emergentes y barreras de diálogo.\n  WebDriver supera la limitación de la política del mismo origen de host único de Selenium RC.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "Alertas, avisos y confirmaciones de JavaScript",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n WebDriver provides an API for working with the three types of native popup message offered by JavaScript. These popups are styled by the browser and offer limited customisation.\nAlerts The simplest of these is referred to as an alert, which shows a custom message, and a single button which dismisses the alert, labelled in most browsers as OK. It can also be dismissed in most browsers by pressing the close button, but this will always do the same thing as the OK button. See an example alert.\nWebDriver can get the text from the popup and accept or dismiss these alerts.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     Confirm A confirm box is similar to an alert, except the user can also choose to cancel the message. See a sample confirm.\nThis example also shows a different approach to storing an alert:\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     Prompt Prompts are similar to confirm boxes, except they also include a text input. Similar to working with form elements, you can use WebDriver\u0026rsquo;s send keys to fill in a response. This will completely replace the placeholder text. Pressing the cancel button will not submit any text. See a sample prompt.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "Evitar compartir estados",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Although mentioned in several places it is worth mentioning again. Ensure tests are isolated from one another.\n Do not share test data. Imagine several tests that each query the database for valid orders before picking one to perform an action on. Should two tests pick up the same order you are likely to get unexpected behaviour.\n Clean up stale data in the application that might be picked up by another test e.g. invalid order records.\n Create a new WebDriver instance per test. This helps ensure test isolation and makes parallelisation simpler.\n  "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/performance_testing/",
	"title": "Pruebas de desempeño",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Performance testing using Selenium and WebDriver is generally not advised. Not because it is incapable but because it is not optimised for the job and you are unlikely to get good results.\nIt may seem ideal to performance test in the context of the user but a suite of WebDriver tests are subjected to many points of external and internal fragility which are beyond your control; for example browser startup speed, speed of HTTP servers, response of third party servers that host JavaScript or CSS, and the instrumentation penalty of the WebDriver implementation itself. Variation at these points will cause variation in your results. It is difficult to separate the difference between the performance of your website and the performance of external resources, and it is also hard to tell what the performance penalty is for using WebDriver in the browser, especially if you are injecting scripts.\nThe other potential attraction is \u0026ldquo;saving time\u0026rdquo; — carrying out functional and performance tests at the same time. However, functional and performance tests have opposing objectives. To test functionality, a tester may need to be patient and wait for loading, but this will cloud the performance testing results and vice versa.\nTo improve the performance of your website, you will need to be able to analyse overall performance independent of environment differences, identify poor code practices, breakdown of performance of individual resources (i.e. CSS or JavaScript) in order to know what to improve. There are performance testing tools available that can do this job already, and which provide reporting and analysis which can even make improvement suggestions.\nExample (open source) packages to use are: JMeter\n"
},
{
	"uri": "https://selenium.dev/documentation/es/remote_webdriver/",
	"title": "WebDriver remoto",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n WebDriver remoto You can use WebDriver remotely the same way you would use it locally. The primary difference is that a remote WebDriver needs to be configured so that it can run your tests on a separate machine.\nA remote WebDriver is composed of two pieces: a client and a server. The client is your WebDriver test and the server is simply a Java servlet, which can be hosted in any modern JEE app server.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/",
	"title": "Guías y recomendaciones",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Guías y recomendaciones A note on \u0026ldquo;Best Practices\u0026rdquo;: We\u0026rsquo;ve intentionally avoided the phrase \u0026ldquo;Best Practices\u0026rdquo; in this documentation. No one approach works for all situations. We prefer the idea of \u0026ldquo;Guidelines and Recommendations\u0026rdquo;. We encourage you to read through these and thoughtfully decide what approaches will work for you in your particular environment.\nFunctional testing is difficult to get right for many reasons. As if application state, complexity, and dependencies do not make testing difficult enough, dealing with browsers (especially with cross-browser incompatibilities) makes writing good tests a challenge.\nSelenium provides tools to make functional user interaction easier, but does not help you write well-architected test suites. In this chapter we offer advice, guidelines, and recommendations. on how to approach functional web page automation.\nThis chapter records software design patterns popular amongst many of the users of Selenium that have proven successful over the years.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/test_independency/",
	"title": "Independencia en las pruebas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Write each test as its own unit. Write the tests in a way that will not be reliant on other tests to complete:\nLet us say there is a content management system with which you can create some custom content which then appears on your website as a module after publishing, and it may take some time to sync between the CMS and the application.\nA wrong way of testing your module is that the content is created and published in one test, and then checking the module in another test. This is not feasible as the content may not be available immediately for the other test after publishing.\nInstead, you can create a stub content which can be turned on and off within the affected test, and use that for validating the module. However, for content creation, you can still have a separate test.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/http_proxies/",
	"title": "Proxies Http",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/link_spidering/",
	"title": "Rastreo de enlaces",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Using WebDriver to spider through links is not a recommended practice not because it cannot be done, but because it’s definitely not the most ideal tool. WebDriver needs time to start up, and can take several seconds up to a minute depending on how your test is written, just to get to the page and traverse through the DOM.\nInstead of using WebDriver for this, you could save a ton of time by executing a curl command, or using a library such as BeautifulSoup since these methods don’t rely on creating a browser and navigating to a page. You are saving tonnes of time by not using WebDriver for this task.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Considerar el uso de un API fluída",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Martin Fowler coined the term \u0026ldquo;Fluent API\u0026rdquo;. Selenium already implements something like this in their FluentWait class, which is meant as an alternative to the standard Wait class. You could enable the Fluent API design pattern in your page object and then query the Google search page with a code snippet like this one:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); The Google page object class with this fluent behavior might look like this:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // If load() fails, calls isLoaded() until page is finished loading  PageFactory.initElements(driver, this); // Initialize WebElements on page  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, 3 ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } }"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/page_loading_strategy/",
	"title": "Estrategia de carga de página",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/",
	"title": "Peores prácticas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Peores prácticas "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/web_element/",
	"title": "Elemento web",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Represents a DOM element. WebElements can be found by searching from the document root using a WebDriver instance, or by searching under another WebElement:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   driver = Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element_by_tag_name(\u0026#34;form\u0026#34;) search_box = search_form.find_element_by_name(\u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = await driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = await searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = ChromeDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/",
	"title": "Grid",
	"tags": [],
	"description": "",
	"content": " Grid Selenium Grid es un servidor proxy inteligente que permite que las pruebas de Selenium enruten comandos a instancias remotas del navegador web. Su objetivo es proporcionar una manera fácil de ejecutar pruebas en paralelo en múltiples máquinas.\nCon Selenium Grid, un servidor actúa como el centro que enruta los comandos de prueba con formato JSON a uno o más nodos de Grid registrados. Las pruebas se ponen en contacto con el concentrador (o hub) para obtener acceso a instancias de explorador remoto. El concentrador tiene una lista de servidores registrados a los que proporciona acceso y nos permite controlar estas instancias.\nSelenium Grid nos permite ejecutar pruebas en paralelo en múltiples máquinas, y administrar diferentes versiones y configuraciones de navegador de forma centralizada (en lugar de en cada prueba individual).\nSelenium Grid no es una solución mágica para todas las situaciones. Resuelve un subconjunto de problemas comunes de delegación y distribución, pero, por ejemplo, no administrará su infraestructura y podría no satisfacer algunas de sus necesidades específicas.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "Nueva instancia del navegador por prueba",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Start each test from a clean known state. Ideally, spin up a new virtual machine for each test. If spinning up a new virtual machine is not practical, at least start a new WebDriver for each test. For Firefox, start a WebDriver with your known profile.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile);"
},
{
	"uri": "https://selenium.dev/documentation/es/driver_idiosyncrasies/",
	"title": "Carácter de los controladores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Carácter de los controladores "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/keyboard/",
	"title": "Teclado",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Represents a KeyBoard event. KeyBoard actions are performed by using low-level interface which allows us to provide virtualized device input to the web browser.\nsendKeys The sendKeys types a key sequence in DOM element even if modifier key sequence is encountered.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.firefox.FirefoxDriver; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver.Firefox() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34;+Keys.ENTER)   using (var driver = new FirefoxDriver()) { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;q\u0026#34; + Keys.Enter); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return ensure driver.quit end   const {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.WebDriver import org.openqa.selenium.WebElement import org.openqa.selenium.ChromeDriver class HelloSelenium { fun main() { driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER) } finally { driver.quit() } } }     "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/mouse/",
	"title": "Mouse",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/",
	"title": "Paquetes de soporte",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Paquetes de soporte "
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/",
	"title": "Legacy",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Legacy Under this section you can find all the documentation related to the legacy components of Selenium. This is meant to be kept purely for historical reasons and not as a incentive to use deprecated components.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/front_matter/",
	"title": "Texto preliminar",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Texto preliminar "
},
{
	"uri": "https://selenium.dev/documentation/es/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://selenium.dev/documentation/es/contributing/",
	"title": "Contribuyendo a la documentación de Selenium",
	"tags": [],
	"description": "",
	"content": " Selenium es un gran proyecto de software y la documentación es clave para comprender cómo funcionan las cosas y aprender formas efectivas de explotar su potencial.\nLa nueva documentación es un proyecto que comenzó a reescribir la documentación de Selenium desde cero. Este es un esfuerzo continuo (no dirigido a ninguna versión específica) para proporcionar un manual actualizado sobre cómo usar Selenium de manera efectiva. Esperamos traer las piezas de la documentación antigua que aún tienen sentido.\nLos aportes a los nuevos documentos siguen el proceso descrito en la sección a continuación sobre las contribuciones. Debería pasar un tiempo familiarizándose con la documentación leyendo más sobre ella.\nEl proyecto Selenium agradece las contribuciones de todos. Hay varias formas de colaborar:\nReportar un problema Al informar un nuevo problema o al comentar problemas existentes, asegúrese de que las discusiones estén relacionadas con temas técnicos concretos con el software Selenium o su documentación.\nTodos los componentes de Selenium cambian bastante rápido en el tiempo, por lo que esto puede hacer que la documentación esté desactualizada. Si considera que este es el caso, como se mencionó, no dude en reportar un problema. También es posible que sepa cómo actualizar la documentación, así que envíenos una solicitud (pull request) con los cambios relacionados.\nSi no está seguro de si lo que encontró es un problema o no, consulte primero a la lista de correo de selenium-users@, o únase a nosotros en el canal #selenium en irc.freenode.org o Slack.\nContribuciones El proyecto Selenium da la bienvenida a nuevos contribuyentes. Las personas que hacen contribuciones significativas y valiosas a lo largo del tiempo se hacen Committers y se les da acceso para realizar commit al proyecto.\nEste documento lo guiará a través del proceso de contribución.\nStep 1: Bifurcar (Fork) Haga fork al proyecto en Github y verifique su copia localmente.\n% git clone git@github.com:username/docs.git % cd docs % git remote add upstream git://github.com/seleniumhq/docs.git Dependencias: Hugo La documentación usa Hugo para construir y renderizar el sitio. Por favor, verifique todo localmente incluso antes de hacer commit a cualquier cambio instale Hugo y corra el servidor local para renderizar el sitio localmente.\nStep 2: Ramificación (Branch) Cree una rama nueva (feature branch) y comience a hackear:\n% git checkout -b my-feature-branch Practicamos el desarrollo basado en HEAD (HEAD-based development), lo que significa que todos los cambios se aplican directamente sobre la rama maestra (master).\nStep 3: Confirmar (Commit) Primero asegúrese de que git sepa su nombre y dirección de correo electrónico:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Escribir buenos mensajes de confirmación (commit) es importante. Un mensaje de confirmación debe describir qué cambió, por qué y los problemas de referencia corregidos (si los hay). Siga estas pautas al escribir uno:\n Procure que el texto sea en inglés. Se colocan los ejemplos en Español para aumentar la comprensión. La primera línea debe tener alrededor de 50 caracteres o menos y contener una breve descripción del cambio. Mantenga la segunda línea en blanco. Envuelva todas las demás líneas en 72 columnas. Incluya Fixes # N, donde N es el número de problema (issue) que corrige la confirmación, si corresponde.  Un buen mensaje de confirmación puede verse así:\nexplicar cometer normativamente en una línea El cuerpo del mensaje de confirmación es unas pocas líneas de texto, que explican las cosas con más detalle, posiblemente brindando algunos antecedentes sobre la resolución del problema, etc. El cuerpo del mensaje de confirmación puede tener varios párrafos y, por favor, ajuste correctamente las palabras y mantenga las columnas con menos de 72 caracteres aproximadamente. De esa manera, \u0026#39;git log\u0026#39; mostrará las cosas muy bien incluso cuando está sangrado. Fixes # 141 La primera línea debe ser significativa, ya que es lo que las personas ven cuando ejecutan git shortlog ogit log --oneline.\nStep 4: Rebase Use git rebase (not git merge) para sincronizar tu trabajo de vez en cuando.\n% git fetch upstream % git rebase upstream/master Paso 5: Prueba Recuerde siempre ejecutar el servidor local, con esto puede estar seguro de que sus cambios no han roto nada.\nPaso 6: Traducciones Si está actualizando los documentos, agregando nuevos o eliminando los obsoletos, recuerde actualizar las traducciones. Por supuesto, es posible que no hables todos los idiomas traducidos en los documentos. Para eso, cree un hallazgo issue donde describa claramente que algo en los documentos ha cambiado y su traducción debe actualizarse. Con eso, alguien que habla ese idioma necesario puede intervenir y ayudarnos a mantenerlo actualizado.\nPaso 7: Firme el CLA Antes de que podamos aceptar, primero le pedimos a las personas que firmen un Acuerdo de licencia de colaborador (o CLA). Pedimos esto para que sepamos que los contribuyentes tienen el derecho de donar el código.\nCuando abre su solicitud (pull request), le pedimos que indique que ha firmado el CLA. Esto reducirá el tiempo que nos lleva integrarlo.\nPaso 8: Empuje (Push) % git push origin my-feature-branch Vaya a https://github.com/yourusername/site.git y presione Pull Request y complete el formulario. Indique que ha firmado el CLA (consulte el Paso 7).\nLas solicitudes generalmente se revisan en unos pocos días. Si hay comentarios que abordar, aplique sus cambios en los nuevos commits (preferiblemente arreglos o fixups) y avance a la misma rama (branch).\nPaso 9: Integración Cuando se completa la revisión del código, un committer tomará su PR (pull request) y lo integrará en la rama (branch) gh-pages de los documentos. Como nos gusta mantener un historial lineal en la rama maestra, normalmente resumiremos los cambios (squash and rebase) del historial de su rama.\nComunicación Los contribuyentes de Selenium frecuentan el canal #selenium en irc.freenode.org o en Slack. También puede unirse a la lista de correo selenium-developers@.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/",
	"title": "El Proyecto para Automatización de Navegadores Selenium",
	"tags": [],
	"description": "",
	"content": " El Proyecto para Automatización de Navegadores Selenium Selenium es un proyecto padre que cobija a una gama de herramientas y bibliotecas que permiten y soportan la automatización de los navegadores web.\nProporciona extensiones para emular la interacción del usuario con los navegadores, un servidor de distribución para escalar la asignación del navegador y la infraestructura para implementaciones de la Especificación W3C del WebDriver que le permite escribir código intercambiable para todos los principales navegadores web.\nEste proyecto es posible gracias a los colaboradores voluntarios que han dedicado miles de horas de su propio tiempo y han hecho que el código fuente esté disponible gratuitamente para que cualquiera pueda usarlo, disfrutarlo y mejorarlo.\nSelenium reúne a proveedores de navegadores, ingenieros y entusiastas para promover una discusión abierta sobre la automatización de la plataforma web. El proyecto organiza una conferencia anual para enseñar y nutrir a la comunidad.\nEn el núcleo de Selenium se encuentra el WebDriver, una interfaz para escribir conjuntos de instrucciones que se pueden ejecutar indistintamente en muchos navegadores. Aquí está una de las instrucciones más simples que puede hacer:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, 10); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #Este ejemplo requiere Selenium WebDriver 3.13 o posterior with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;))) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.WebDriver import org.openqa.selenium.WebElement import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.WebDriverWait import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated class HelloSelenium { public main(args: Array\u0026lt;String\u0026gt;) { val driver = new FirefoxDriver() val wait = new WebDriverWait(driver, 10) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } } }     Consulte la Guía rápida para obtener una explicación completa de lo que sucede detrás de escena cuando ejecuta este código. Debe continuar con la documentación narrativa para comprender cómo puede instalar y utilizar con éxito Selenium como herramienta de automatización de pruebas, y escalar pruebas simples como esta para ejecutar en entornos grandes y distribuidos en múltiples navegadores, en varios sistemas operativos diferentes.\nEmpezando Si es nuevo en Selenium, tenemos algunos recursos que pueden ayudarlo a ponerse al día de inmediato.\n Guía rápida  El WebDriver Control remoto IDE Grid HTML Runner   "
},
{
	"uri": "https://selenium.dev/documentation/es/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]